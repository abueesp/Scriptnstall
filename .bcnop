#######################################
## BC File - Programmable Calculator ##
##     without primes functions      ##
#######################################

###from https://github.com/abueesp/Scriptnstall
### MaxScale - Get the maximum scale from your GNU BC
### BC is currently only 32bit in all cases. 
### The package manager recognizes that it might have to install 32bit libraries for a 64 bit environment, but continue to be 32 bits libraries.
### That is why your maximum scale is always 2147483646, or 1111111111111111111111111111110 bits. ### If you try to add just 1 bit more, you will get a fatal error 'Out of memory for malloc'.
### Which explain that more memory can't be allocated, even if there is not an overflow because you are running a >32 bits computer.
define maxscale() {
  scale=2147483646
  print "Your scale is now at 2147483646, or 32 bits\n"
}

###from phodd.net/gnu-bc/code/funcs.bc
### Funcs.BC - a large number of functions for use with GNU BC
  ## Not to be regarded as suitable for any purpose
  ## Not guaranteed to return correct answers
### A large suite of functions to complement the bc standard library. Unlike the standard library (activated with bc -l), all function names are spelled out in full. Full name aliases for the standard library functions are provided.
###    Integer and Rounding
###    Trigonometry
###    Hyperbolic Trigonometry
###    Exponential / Logarithms
###    Powers / Roots
###    Lambert W
###    Triangular numbers
###    Polygonal numbers
###    Tetrahedral numbers
###    Arithmetic-Geometric mean 
define pi() {
  auto s;
  if(scale==(s=scale(pi_)))return pi_
  if(scale<s)return pi_/1
  scale+=5;pi_=a(1)*4;scale-=5
  return pi_/1
}
define phi(){return((1+sqrt(5))/2)} ; phi = phi()
define psi(){return((1-sqrt(5))/2)} ; psi = psi()

# Reset base to ten
obase=ibase=A;

## Integer and Rounding

# Round to next integer nearest 0:  -1.99 -> 1, 0.99 -> 0
define int(x) { auto os;os=scale;scale=0;x/=1;scale=os;return(x) } 

# Round down to integer below x
define floor(x) {
  auto os,xx;os=scale;scale=0
  xx=x/1;if(xx>x).=xx--
  scale=os;return(xx)
}

# Round up to integer above x
define ceil(x) {
  auto os,xx;x=-x;os=scale;scale=0
  xx=x/1;if(xx>x).=xx--
  scale=os;return(-xx)
}

# Fractional part of x:  12.345 -> 0.345
define frac(x) {
  auto os,xx;os=scale;scale=0
  xx=x/1;if(xx>x).=xx--
  scale=os;return(x-xx)
}

# Absolute value of x
define abs(x) { if(x<0)return(-x)else return(x) }

# Sign of x
define sgn(x) { if(x<0)return(-1)else if(x>0)return(1);return(0) }

# Round x up to next multiple of y
define round_up(  x,y) { return(y*ceil( x/y )) }

# Round x down to previous multiple of y
define round_down(x,y) { return(y*floor(x/y )) }

# Round x to the nearest multiple of y
define round(x,y) {
  auto os,oib;
  os=scale;oib=ibase
  .=scale++;ibase=A
    y*=floor(x/y+.5)
  ibase=oib;scale=os
  return y
}

# Find the remainder of x/y
define int_remainder(x,y) {
  auto os;
  os=scale;scale=0
   x/=1;y/=1;x%=y
  scale=os
  return(x)
}
define remainder(x,y) {
  os=scale;scale=0
   if(x==x/1&&y==y/1){scale=os;return int_remainder(x,y)}
  scale=os
  return(x-round_down(x,y))
}

# Greatest common divisor of x and y
define int_gcd(x,y) {
  auto r,os;
  os=scale;scale=0
  x/=1;y/=1
  while(y>0){r=x%y;x=y;y=r}
  scale=os
  return(x)
}
define gcd(x,y) {
  auto r,os;
  os=scale;scale=0
   if(x==x/1&&y==y/1){scale=os;return int_gcd(x,y)}
  scale=os
  while(y>0){r=remainder(x,y);x=y;y=r}
  return(x)
}

# Lowest common multiple of x and y
define int_lcm(x,y) {
  auto r,m,os;
  os=scale;scale=0
  x/=1;y/=1
  m=x*y
  while(y>0){r=x%y;x=y;y=r}
  m/=x
  scale=os
  return(m)
}
define lcm(x,y) { return (x*y/gcd(x,y)) }

# Remove largest possible power of 2 from x
define oddpart(x){
  auto os;
  os=scale;scale=0;x/=1
  if(x==0){scale=os;return 1}
  while(!x%2)x/=2
  scale=os;return x
}

# Largest power of 2 in x
define evenpart(x) {
  auto os;
  os=scale;scale=0
  x/=oddpart(x/1)
  scale=os;return x
}

## Trig / Hyperbolic Trig

# Sine
define sin(x) { return s(x) } # alias for standard library
# Cosine
define c(x)   { return s(x+pi()/2) } # as fast or faster than
define cos(x) { return c(x)        } # . standard library
# Tangent
define tan(x)   { auto c;c=c(x);if(c==0)c=A^-scale;return(s(x)/c) }

# Secant
define sec(x)   { auto c;c=c(x);if(c==0)c=A^-scale;return(   1/c) }
# Cosecant
define cosec(x) { auto s;s=s(x);if(s==0)s=A^-scale;return(   1/s) }
# Cotangent
define cotan(x) { auto s;s=s(x);if(s==0)s=A^-scale;return(c(x)/s) }

# Arcsine
define arcsin(x) { if(x==-1||x==1)return(pi()/2*x);return( a(x/sqrt(1-x*x)) ) } 
# Arccosine
define arccos(x) { if(x==0)return(0);return pi()/2-arcsin(x) }

# Arctangent (one argument)
define arctan(x)  { return a(x) } # alias for standard library

# Arctangent (two arguments)
define arctan2(x,y) { 
  auto p;
  if(x==0&&y==0)return(0)
  p=(1-sgn(y))*pi()*(2*(x>=0)-1)/2
  if(x==0||y==0)return(p)
  return(p+a(x/y))
}

# Arcsecant
define arcsec(x)      { return( a(x/sqrt(x*x-1)) ) }
# Arccosecant
define arccosec(x)    { return( a(x/sqrt(x*x-1))+pi()*(sgn(x)-1)/2 ) }
# Arccotangent (one argument)
define arccotan(x)    { return( a(x)+pi()/2 ) }
# Arccotangent (two arguments)
define arccotan2(x,y) { return( arctan(x,y)+pi()/2 ) }

# Hyperbolic Sine
define sinh(x) { auto t;t=e(x);return((t-1/t)/2) }
# Hyperbolic Cosine
define cosh(x) { auto t;t=e(x);return((t+1/t)/2) }
# Hyperbolic Tangent
define tanh(x) { auto t;t=e(x+x)-1;return(t/(t+2)) }

# Hyperbolic Secant
define sech(x)   { auto t;t=e(x);return(2/(t+1/t)) }
# Hyperbolic Cosecant
define cosech(x) { auto t;t=e(x);return(2/(t-1/t)) }
# Hyperbolic Cotangent
define coth(x)   { auto t;t=e(x+x)-1;return((t+2)/t) }

# Hyperbolic Arcsine
define arcsinh(x) { return( l(x+sqrt(x*x+1)) ) }
# Hyperbolic Arccosine
define arccosh(x) { return( l(x+sqrt(x*x-1)) ) }
# Hyperbolic Arctangent
define arctanh(x) { return( l((1+x)/(1-x))/2 ) }

# Hyperbolic Arcsecant
define arcsech(x)   { return( l((sqrt(1-x*x)+1)/x) ) }
# Hyperbolic Arccosecant
define arccosech(x) { return( l((sqrt(1+x*x)*sgn(x)+1)/x) ) }
# Hyperbolic Arccotangent
define arccoth(x)   { return( l((x+1)/(x-1))/2 ) }

# Length of the diagonal vector (0,0)-(x,y) [pythagoras]
define pyth(x,y) { return(sqrt(x*x+y*y)) }
define pyth3(x,y,z) { return(sqrt(x*x+y*y+z*z)) }

# Gudermannian Function
define gudermann(x)    { return 2*(a(e(x))-a(1)) }
# Inverse Gudermannian Function
define arcgudermann(x) {
  return arctanh(s(x))
}

# Bessel function
define besselj(n,x) { return j(n,x) } # alias for standard library

## Exponential / Logs

# Exponential e^x
define exp(x) { return e(x) } # alias for standard library

# Natural Logarithm (base e)
define ln(x) {
  auto os,len,ln;
  if(x< 0){print "ln error: logarithm of a negative number\n";return 0}
  if(x==0)print "ln error: logarithm of zero; negative infinity\n"
  len=length(x)-scale(x)-1
  if(len<A)return l(x);
  os=scale;scale+=length(len)+1
  ln=l(x/A^len)+len*l(A)
  scale=os
  return ln/1
} # speed improvement on standard library

# workhorse function for pow and log - new, less clever version
# Helps determine whether a fractional power is legitimate for a negative number
# . expects to be fed a positive value
# . returns -odd for even/odd; odd2 for odd1/odd2;
#           even for odd/even;   -2 for irrational
# . note that the return value is the denominator of the fraction if the
#   fraction is rational, and the sign of the return value states whether
#   the numerator is odd (positive) or even (negative)
# . since even/even is not possible, -2 is used to signify irrational
define id_frac2_(y){
  auto os,oib,es,eps,lim,max,p,max2,i,cf[],f[],n,d,t;
  os=scale
  if(cf_max){
    # cf.bc is present!
    .=cf_new(cf[],y);if(scale(cf[0]))return -2;
    .=frac_from_cf(f[],cf[],1)
    d=f[0];scale=0;if(f[1]%2==0)d=-d;scale=os
   return d
  }
  oib=ibase;ibase=A
  scale=0
   es=3*os/4
  scale=os
   eps=A^-es
   y+=eps/A
  scale=es
   y/=1
  scale=0
  if(y<0)y=-y
  d=y-(n=y/1)
  if(d<eps){t=2*(n%2)-1;scale=os;ibase=oib;return t}#integers are x/1
  t=y/2;t=y-t-t
  # Find numerator and denominator of fraction, if any
  lim=A*A;max2=A^5*(max=A^int(os/2));p=1
  i=0;y=t
  while(1) {
    scale=es;y=1/y;scale=0
    y-=(t=cf[++i]=y/1);p*=1+t
    if(i>lim||(max<p&&p<max2)){cf[i=1]=-2;break}#escape if number seems irrational    
    if((p>max2||3*length(t)>es+es)&&i>1){cf[i--]=0;break}#cheat: assume rational
    if(y==0)break;#completely rational
  }
  n=1;d=cf[i]
  if(i==0){print "id_frac2_: something is wrong; y=",y,", d=",d,"\n"}
  if(d!=-2&&i)while(--i){d=n+cf[i]*(t=d);n=t}
  if(d<A^os){d*=2*(n%2)-1}else{d=-2}
  scale=os;ibase=oib
  return d;
}

# raise x to integer power y faster than bc's x^y
# . it seems bc (at time of writing) uses
# . an O(n) repeated multiplication algorithm
# . for the ^ operator, which is inefficient given
# . that there is a simple O(log n) alternative:
define fastintpow__(x,y) {
  auto r,hy;
  if(y==0)return(1)
  if(y==1)return(x)
  r=fastintpow__(x,hy=y/2)
  r*=r;if(hy+hy<y)r*=x
  return( r )
}
define fastintpow_(x,y) {
  auto ix,os;
  if(y<0)return fastintpow_(1/x,-y)
  if(y==0)return(1)
  if(y==1)return(x)
  if(x==1)return(1)
  os=scale;scale=0
  if(x==-1){y%=2;y+=y;scale=os;return 1-y}
  # bc is still faster for integers
  if(x==(ix=x/1)){scale=os;return ix^y}
  # ...and small no. of d.p.s, but not for values <= 2
  if(scale(x)<3&&x>2){scale=os;return x^y}
  scale=os;x/=1;scale=0
  x=fastintpow__(x,y);
  scale=os;return x;
}

# Raise x to a fractional power faster than e^(y*l(x))
define fastfracpow_(x,y) {
  auto f,yy,inv;
  inv=0;if(y<0){y=-y;inv=1}
  y-=int(y)
  if(y==0)return 1;
  if((yy=y*2^C)!=int(yy)){x=l(x);if(inv)x=-x;return e(y/1*x)}
  # faster using square roots for rational binary fractions
  # where denominator <= 8192
  x=sqrt(x)
  for(f=1;y&&x!=1;x=sqrt(x))if(y+=y>=1){.=y--;f*=x}
  if(inv)f=1/f;
  return f;
}

# Find the yth root of x where y is integer
define fastintroot_(x,y) {
  auto os,d,r,ys,eps;
  os=scale;scale=0;y/=1;scale=os
  if(y<0){x=1/x;y=-y}
  if(y==1){return x}
  if(y>=x-1){return fastfracpow_(x,1/y)}
  if(y*int((d=2^F)/y)==d){
    r=1;while(r+=r<=y)x=sqrt(x)
    return x
  }
  scale=length(y)-scale(y);if(scale<5)scale=5;r=e(ln(x)/y)
  scale=os+5;if(scale<5)scale=5
  d=1;eps=A^(3-scale)
  ys=y-1
  while(d>eps){
    d=r;r=(ys*r+x/fastintpow_(r,ys))/y
    d-=r;if(d<0)d=-d
  }
  scale=os
  return r/1
}

# Raise x to the y-th power
define pow(x,y) {
 auto os,p,ix,iy,fy,dn,s;
 if(y==0) return 1
 if(x==0) return 0
 if(0<x&&x<1){x=1/x;y=-y}
 os=scale;scale=0
  ix=x/1;iy=y/1;fy=y-iy;dn=0
 scale=os;#scale=length(x/1)
 if(y!=iy&&x<0){
   dn=id_frac2_(y)# -ve implies even numerator
   scale=0;if(dn%2){# odd denominator
     scale=os
     if(dn<0)return  pow(-x,y) # even/odd
     /*else*/return -pow(-x,y) #  odd/odd
   }
   print "pow error: "
   if(dn>0) print "even root"
   if(dn<0) print "irrational power"
   print " of a negative number\n"
   scale=os;return 0
 }
 if(y==iy) {
   if(x==ix){p=fastintpow_(ix,iy);if(iy>0){scale=0;p/=1};scale=os;return p/1}
   scale+=scale;p=fastintpow_(x,iy);scale=os;return p/1
 }
 if((dn=id_frac2_(y))!=-2){ #accurate rational roots (sometimes slower)
   if(dn<0)dn=-dn
   s=1;if(y<0){y=-y;s=-1}
   p=y*dn+1/2;scale=0;p/=1;scale=os
   if(p<A^3)x=fastintpow_(x,p)
   x=fastintroot_(x,dn)
   if(p>=A^3)x=fastintpow_(x,p)
   if(s<0)x=1/x
   return x
 }
 p=fastintpow_(ix,iy)*fastfracpow_(x,fy);
 scale=os+os
 if(ix)p*=fastintpow_(x/ix,iy)
 scale=os
 return p/1
 #The above is usually faster and more accurate than
 # return( e(y*l(x)) );
}

# y-th root of x [ x^(1/y) ]
define root(x,y) {
  return pow(x,1/y)
}

# Specific cube root function
# = stripped down version of fastintroot_(x,3)
define cbrt(x) {
  auto os,d,r,eps;
  if(x<0)return -cbrt(-x)
  if(x==0)return 0
  os=scale;scale=0;eps=A^(scale/3)
  if(x<eps){scale=os;return 1/cbrt(1/x)}
  scale=5;r=e(ln(x)/3)
  scale=os+5;if(scale<5)scale=5
  d=1;eps=A^(3-scale)
  while(d>eps){
    d=r;r=(r+r+x/(r*r))/3
    d-=r;if(d<0)d=-d
  }
  scale=os
  return r/1
}

# Logarithm of x in given base:  log(2, 32) = 5 because 2^5 = 32
#  tries to return a real answer where possible when given negative numbers
#  e.g.     log(-2,  64) = 6 because (-2)^6 =   64
#  likewise log(-2,-128) = 7 because (-2)^7 = -128
define log(base,x) {
  auto os,i,l,sx,dn,dnm2;
  if(base==x)return 1;
  if(x==0){print "log error: logarithm of zero; negative infinity\n";     return  l(0)}
  if(x==1)return 0;
  if(base==0){print "log error: zero-based logarithm\n";                  return    0 }
  if(base==1){print "log error: one-based logarithm; positive infinity\n";return -l(0)}
  scale+=6
  if((-1<base&&base<0)||(0<base&&base<1)){x=-log(1/base,x);scale-=6;return x/1}
  if((-1<x   &&   x<0)||(0<x   &&   x<1)){x=-log(base,1/x);scale-=6;return x/1}
  if(base<0){
    sx=1;if(x<0){x=-x;sx=-1}
    l=log(-base,x)
    dn=id_frac2_(l)
    os=scale;scale=0;dnm2=dn%2;scale=os
    if(dnm2&&dn*sx<0){scale-=6;return l/1}
    print "log error: -ve base: "
    if(dnm2)print "wrong sign for "
    print "implied "
    if(dnm2)print "odd root/integer power\n"
    if(!dnm2){
      if(dn!=-2)print "even root\n"
      if(dn==-2)print "irrational power\n"
    }
    scale-=6;return 0;
  }
  if(x<0){
    print "log error: +ve base: logarithm of a negative number\n"
    scale-=6;return 0;
  }
  x=ln(x)/ln(base);scale-=6;return x/1
}

# Integer-only logarithm of x in given base
# (compare digits function in digits.bc)
define int_log(base,x) { 
 auto os,p,c;
 if(0<x&&x<1) {return -int_log(base,1/x)}
 os=scale;scale=0;base/=1;x/=1
  if(base<2)base=ibase;
  if(x==0)    {scale=os;return  1-base*A^os}
  if(x<base)  {scale=os;return  0    }
  c=length(x) # cheat and use what bc knows about decimal length
  if(base==A){scale=os;return c-1}
  if(base<A){if(x>A){c*=int_log(base,A);c-=2*(base<4)}else{c=0}}else{c/=length(base)+1}
  p=base^c;while(p<=x){.=c++;p*=base}
  scale=os;return(c-1)
}

# Lambert's W function 0 branch; Numerically solves w*e(w) = x for w
# * is slow to converge near -1/e at high scales
define lambertw0(x) {
  auto oib, a, b, w, ow, lx, ew, e1, eps;
  if(x==0) return 0;
  oib=ibase;ibase=A
  ew = -e(-1)
  if (x<ew) {
    print "lambertw0: expected argument in range [-1/e,oo)\n"
    ibase=oib
    return -1
  }
  if (x==ew) {ibase=oib;return -1}
  # First approximation from :
  #   http://www.desy.de/~t00fri/qcdins/texhtml/lambertw/
  #   (A. Ringwald and F. Schrempp)
  # via Wikipedia
  if(x < 0){
    w = x/ew
  } else if(x < 500){
    lx=l(x+1);w=0.665*(1+0.0195*lx)*lx+0.04
  } else if((lx=length(x)-scale(x))>5000) {
    lx*=l(A);w=lx-(1-1/lx)*l(lx)
  } else {
    lx=l(x);w=l(x-4)-(1-1/lx)*l(lx)
  } 
  # Iteration adapted from code found on Wikipedia
  #   apparently by an anonymous user at 147.142.207.26
  #   and later another at 87.68.32.52
  ow = 0
  eps = A^-scale
  scale += 5
  e1 = e(1)
  while(abs(ow-w)>eps&&w>-1){
    ow = w
    if(x>0){ew=pow(e1,w)}else{ew=e(w)}
    a = w*ew
    b = a+ew
    a -= x;
    if(a==0)break
    b = b/a - 1 + 1/(w+1)
    w -= 1/b
    if(x<-0.367)w-=eps
  }
  scale -= 5
  ibase=oib
  return w/1
}

# Lambert's W function -1 branch; Numerically solves w*e(w) = x for w
# * is slow to converge near -1/e at high scales
define lambertw_1(x) {
  auto oib,os,oow,ow,w,ew,eps,d,iters;
  oib=ibase;ibase=A
  ew = -e(-1)
  if(ew>x||x>=0) {
    print "lambertw_1: expected argument in [-1/e,0)\n"
    ibase=oib
    if(x==0)return 1-A^scale
    if(x>0)return 0
    return -1
  }
  if(x==ew) return -1;
  os=scale
  eps=A^-os
  scale+=3
  oow=ow=0
  w=x
  w=l(-w)
  w-=l(-w)
  w+=sqrt(eps)
  iters=0
  while(abs(ow-w)>eps){
    oow=ow;ow=w
    if(w==-1)break
    w=(x*e(-w)+w*w)/(w+1)
    if(iters++==A+A||oow==w){iters=0;w-=A^-scale;scale+=2}
  }
  scale=os;ibase=oib
  return w/1
}

# LambertW wrapper; takes most useful branch based on x
# to pick a branch manually, use lambertw_1 or lambertw0 directly
define w(x) {
  if(x<0)return lambertw_1(x)
  return lambertw0(x)
}

# Faster calculation of lambertw0(exp(x))
# . avoids large intermediate value and associated slowness
# . numerically solves x = y+ln(y) for y
define lambertw0_exp(x) {
  auto oy,y,eps;
  # Actual calculation is faster for x < 160 or thereabouts
  if(x<C*D)return lambertw0(e(x));
  oy=0;y=l(x);y=x-y+y/x;eps=A^-scale
  while(abs(oy-y)>eps)y=x-l(oy=y)
  return y
}

# Shorthand alias for the above
define w_e(x){ return lambertw0_exp(x) }

# Numerically solve pow(y,y) = x for y
define powroot(x) {
  auto r;
  if(x==0) {
    print "powroot error: attempt to solve for zero\n"
    return 0
  }
  if(x==1||x==-1) {return x}
  if(x<=r=e(-e(-1))){
    print "powroot error: unimplemented for values\n  <0";r
    return 0
  }
  r = ln(x)
  r /= w(r)
  return r
}

## Triangular numbers

# xth triangular number
define tri(x) {
  auto xx
  x=x*(x+1)/2;xx=int(x)
  if(x==xx)return(xx)
  return(x)
}

# 'triangular root' of x
define trirt(x) {
  auto xx
  x=(sqrt(1+8*x)-1)/2;xx=int(x)
  if(x==xx)x=xx
  return(x)
}

# Workhorse for following 2 functions
define tri_step_(t,s) {
  auto tt
  t=t+(1+s*sqrt(1+8*t))/2;tt=int(t)
  if(tt==t)return(tt)
  return(t)
}

# Turn tri(x) into tri(x+1) without knowing x
define tri_succ(t) {
  return(tri_step_(t,0+1))
}

# Turn tri(x) into tri(x-1) without knowing x
define tri_pred(t) {
  return(tri_step_(t,0-1))
}

## Polygonal Numbers

# the xth s-gonal number:
#   e.g. poly(3, 4) = tri(4) = 1+2+3+4 = 10; poly(4, x) = x*x, etc
define poly(s, x) {
  auto xx
  x*=(s/2-1)*(x-1)+1;xx=int(x);if(x==xx)x=xx
  return x
}

# inverse of the above = polygonal root:
#   e.g. inverse_poly(3,x)=trirt(x); inverse_poly(4,x)=sqrt(x), etc
define inverse_poly(s, r) {
  auto t,xx
  t=(s-=2)-2
  r=(sqrt(8*s*r+t*t)+t)/s/2;xx=int(r);if(r==xx)r=xx
  return r
}

# converse of poly(); solves poly(s,x)=r for s
#   i.e. if the xth polygonal number is r, how many sides has the polygon?
#   e.g. if the 5th polygonal number is 15, converse_poly(5,15) = 3
#     so the polygon must have 3 sides! (15 is the 5th triangular number)
define converse_poly(x,r) {
  auto xx
  x=2*((r/x-1)/(x-1)+1);xx=int(x);if(x==xx)x=xx
  return x
}

## Tetrahedral numbers

# nth tetrahedral number
define tet(n) { return n*(n+1)*(n+2)/6 }

# tetrahedral root = inverse of the above
define tetrt(t) {
  auto k,c3,w;
  if(t==0)return 0
  if(t<0)return -2-tetrt(-t)
  k=3^5*t*t-1
  if(k<0){print "tetrt: unimplemented for 0<|t|<sqrt(3^-5)\n"; return 0}
  c3=cbrt(3)
  k=cbrt(sqrt(3*k)+3^3*t)
  return k/c3^2+1/(c3*k)-1
}

## Arithmetic-Geometric mean

define arigeomean(a,b) {
  auto c,s;
  if(a==b)return a;
  s=1;if(a<0&&b<0){s=-1;a=-a;b=-b}
  if(a<0||b<0){print "arigeomean: mismatched signs\n";return 0}
  while(a!=b){c=(a+b)/2;a=sqrt(a*b);b=c}
  return s*a
}

# solve n = arigeomean(x,y)
define inv_arigeomean(n, y){
  auto ns,ox,x,b,c,d,i,s,eps;
  if(n==y)return n;
  s=1;if(n<0&&y<0){s=-1;n=-n;y=-y}
  if(n<0||y<0){print "inv_arigeomean: mismatched signs\n";return 0}  
  if(n<y){x=y;y=n;n=x}
  n/=y
  scale+=2;eps=A^-scale;scale+=4
  ns=scale
  x=n*(1+ln(n));ox=-1
  for(i=0;i<A;i++){
    # try to force quadratic convergence
    if(abs(x-ox)<eps){i=-1;break}
    ox=x;scale+=scale
    b=x+x/n*(n-arigeomean(1,x));
    c=b+b/n*(n-arigeomean(1,b));
    d=b+b-c-x
    if(d){x=(b*b-c*x)/d}else{x=b;i=-1;break}
    scale=ns
  }
  if(i!=-1){
    # give up and converge linearly
    x=(x+ox)/2
    while(abs(x-ox)>eps){ox=x;x+=x/n*(n-arigeomean(1,x))}
  }
  x+=5*eps
  scale-=6;return x*y/s
}


###from http://phodd.net/gnu-bc/code/array.bc
### Array.BC - tools for managing arrays
###            uses the undocumented pass-by-reference for arrays
max_array_ = 4^8-1
## Conventions used in this library
###    Comparison
###    Reversal
###    Searching
###    Sorting
###    Unique values
###    Run-length counting
###    Format conversion 

/*
 * All function names begin with the letter 'a'
 * All array parameters have a double underscore at the end of the name
   since some versions of bc are scope-confused by the undocumented pbr
 * The last letter of function names indicates the type of array parameter(s)
   expected. These are:
   * r  = range; A range of array indices will be provided by the caller and
          the array type is therefore moot.
        * A number before the r suggests different ranges from different
          array parameters.
        * Range-specifying parameters always follow the array parameter.
   * 0  = zero terminated; An element of zero indicates the element after
          the last in the array. First element is always index zero
          Advantage: Functions have the shortest possible parameter lists.
          Disadvantage: Zero can't be used within this type of array.
   * b  = before; All elements before a given sentinel value are treated as
          the array. First element is index zero as for zero terminated.
   * u  = upto; only used for the aprintu function; deliberately displays the
          terminator for arrays that are otherwise zero/sentinel terminated
   * l  = length provided; Array index zero contains the length of the rest
          of the array, putting the first element at index one and the last
          at the index specified by the length.
   * (no last letter) = Array begins at index zero and the length will be
          provided by the function caller
*/
##

## Internal functions ##

# For those functions which use start and end as parameters for a range,
# use POSIX scope to sanitise those variables
define asanerange_() {
  auto t;
  if(start>end){t=start;start=end;end=t}
  if(start<0)start=0;
  if(end>max_array_)end=max_array_;
}
define asanerange2_() {
  auto start,end;
  start=astart;end=aend;.=asanerange_();astart=start;aend=end
  start=bstart;end=bend;.=asanerange_();bstart=start;bend=end
}

## Sorting ##

# Sort a subsection of an array
# . from index 'start' to index 'end' inclusive
define asortr(*a__[],start,end) { # non-recursive run-finding mergesort
  auto r[],b__[],i,j,k,ri,p,p2,ri_p2,m,mn,mid,subend;
  .=asanerange_();
  r[ri=0]=start;
  i=start;while(i<end){
    while(i<end&&a__[j=i]<=a__[++j])i=j
    if(i>r[ri])r[++ri]=++i;
    while(i<end&&a__[j=i]>a__[++j])i=j
    if(i>(k=r[ri])){ # reverse backward runs
      j=i;while(j>k){t=a__[j];a__[j--]=a__[k];a__[k++]=t}
      r[++ri]=++i;
    }
  }
  r[++ri]=++end;
  for(p=1;p<ri;p=p2){
    ri_p2=ri-(p2=p+p)
    for(m=0;m<=ri_p2;m=mn){
      # merge a__[r[m]..r[m+p]-1] with a__[r[m+p]..a[r[m+2p]-1]
      i=r[m];mid=j=r[m+p];subend=r[mn=m+p2];k=0
      while(i<mid&&j<subend)
         if(a__[i]<a__[j]){ b__[k++]=a__[i++]
                     }else{ b__[k++]=a__[j++]}
      while(i<mid          )b__[k++]=a__[i++]
      while(k)a__[--j]=b__[--k]
    }
    if(m<ri){
      # roll in any outlier
      # merge a[r[m-p-p]..a[r[m]-1] with a[r[m]..r[ri]-1]
      i=r[m-p2];mid=j=r[m];k=0
      while(i<mid&&j<end)
         if(a__[i]<a__[j]){b__[k++]=a__[i++]
                     }else{b__[k++]=a__[j++]}
      while(i<mid       )  b__[k++]=a__[i++]
      while(k)a__[--j]=b__[--k]
      r[ri=m]=end
    }
  }
  return 0;
}

define asortr_old(*a__[],start,end) { # plain recursive mergesort
  auto os,i,j,k,t,mid,b__[];
  if(end==start)return 0;
  .=asanerange_();
  if(end-start==1){
    if(a__[start]>a__[end]){t=a__[start];a__[start]=a__[end];a__[end]=t}
    return 0;
  }
  os=scale;scale=0;mid=(start+end)/2;scale=os
  i=start;j=mid+1
  if(i<mid).=asortr_old(a__[],start,mid)
  if(j<end).=asortr_old(a__[],mid+1,end)
  k=0
  while(i<=mid&&j<=end)
     if(a__[i]<a__[j]){b__[k++]=a__[i++]
                 }else{b__[k++]=a__[j++]}
  while(i<=mid        )b__[k++]=a__[i++]
 #while(        j<=end)b__[k++]=a__[j++]
  while(k>0)a__[--j]=b__[--k]
  return 0;
}

# Sort all elements of array before zero terminator
define asort0(*a__[]){
  auto i;
  for(i=0;a__[i];i++){}
  .=asortr(a__[],0,i-1)
}

# Sort all elements of array before given terminator, x
define asortb(*a__[],x){
  auto i;
  for(i=0;a__[i]!=x;i++){}
  .=asortr(a__[],0,i-1);
}

# Sort all elements of array with length in [0]
define asortl(*a__[]){
  .=asortr(a__[],1,a__[0]);
}

# Sort the first n elements of an array
define asort(*a__[],n) { .=asortr(a__[],0,n-1) }

## Unique values / Run length finding ##

# Store values from a in v & how many times they occur together in a run in r
# e.g. if a=={7,8,8,9,9,6,9}, v <- {7,8,9,6,9} and r <- {1,2,2,1,1}
define arunlengthr(*v__[],*r__[], a__[],start,end) {
  auto vri,i,prev;
  .=asanerange_();
  if(end==start)return 0;
  vri=0;prev=v__[vri]=a__[start];r__[vri]=1
  for(i=start+1;i<=end;i++)if(a__[i]==prev){
     .=r__[vri]++
    } else {
      r__[++vri]=1; prev=v__[vri]=a__[i]
    }
  return ++vri
}
define arunlength0(*v__[],*r__[], a__[]) {
  auto vri,i,prev;
  if(!a__[0])return 0;
  vri=0;prev=v__[vri]=a__[0];r__[vri]=1
  for(i=1;i<=max_array_&&a__[i];i++)if(a__[i]==prev){
     .=r__[vri]++
    } else {
      r__[++vri]=1; prev=v__[vri]=a__[i]
    }
  .=vri++
  r__[vri]=v__[vri]=0
  return vri
}
define arunlengthb(*v__[],*r__[], a__[],x) {
  auto vri,i,prev;
  if(a__[0]==x)return 0;
  vri=0;prev=v__[vri]=a__[0];r__[vri]=1
  for(i=1;i<=max_array_&&a__[i]!=x;i++)if(a__[i]==prev){
     .=r__[vri]++
    } else {
      r__[++vri]=1; prev=v__[vri]=a__[i]
    }
  .=vri++
  r__[vri]=v__[vri]=x
  return vri
}
define arunlengthl(*v__[],*r__[], a__[]) {
  auto vri,i,prev;
  if(!a__[0])return 0;
  vri=1;prev=v__[vri]=a__[1];r__[vri]=1
  for(i=2;i<=max_array_&&a__[i]!=x;i++)if(a__[i]==prev){
     .=r__[vri]++
    } else {
      r__[++vri]=1; prev=v__[vri]=a__[i]
    }
  return r__[0]=v__[0]=vri
}
define arunlength(*v__[],*r__[], a__[], n) {
  return arunlengthr(v__[],r__[], a__[],0,n-1)
}

# Fill v with the unique values from a. Works best on a sorted array.
define auniqr(*v__[], a__[],start,end) {
  auto r[];
  return arunlengthr(v__[],r[], a__[],start,end)
}
define auniq0(*v__[], a__[]) {
  auto r[];
  return arunlength0(v__[],r[], a__[])
}
define auniqb(*v__[], a__[],x) {
  auto r[];
  return arunlengthb(v__[],r[], a__[],x)
}
define auniql(*v__[], a__[]) {
  auto r[];
  return arunlengthl(v__[],r[], a__[])
}
define auniq(*v__[], a__[],n) {
  auto r[];
  return arunlengthr(v__[],r[], a__[],0,n-1)
}

## Order reversal ##

# Reverse a subsection of an array
define areverser(*a__[],start,end) {
  auto t;
  .=asanerange_();
  if(end==start)return 0
  while(start<end){t=a__[start];a__[start++]=a__[end];a__[end--]=t}
  return 0;
}

# Reverse order of all elements of array before given terminator, x
define areverseb(*a__[],x){
  auto i;
  for(i=0;a__[i]!=x;i++){}
  .=areverser(a__[],0,i-1);
}

# Reverse order of all elements of array before zero terminator
define areverse0(*a__[]){
  auto i;
  for(i=0;a__[i];i++){}
  .=areverser(a__[],0,i-1)
}

# Reverse order of all elements of array 1 .. a[0]
define areversel(*a__[]) {
  .=areverser(a__[],1,a__[0]);
}

# Reverse the first n elements of an array
define areverse(*a__[],n) { .=areverser(a__[],0,n-1) }

## Copying ##

# Make a__[astart..aend] = b__[bstart..bend]
# . Does not expand a__[] to make room if b__[bstart..bend] is too large!
define acopy2r(*a__[],astart,aend,b__[],bstart,bend){
  auto i,j;
  .=asanerange2_();
  i=astart;j=bstart;while(i<=aend&&j<=bend)a__[i++]=b__[j++]
}

# Make a__[start..end] = b__[start..end]
define acopyr(*a__[],b__[],start,end){
  auto i;
  .=asanerange_();
  for(i=start;i<=end;i++)a__[i]=b__[i]
}

# copy a zero-terminated array; a = b
define acopy0(*a__[],b__[]) {
  auto e,i;
  for(i=0;i<=max_array_&&e=b__[i];i++)a__[i]=e
  if(i<=max_array_)a__[i]=0
}

# copy an x terminated array; a = b
define acopyb(*a__[],b__[],x) {
  auto e,i;
  for(i=0;i<=max_array_&&(e=b__[i])!=x;i++)a__[i]=e
  if(i<=max_array_)a__[i]=x
}

# Copy array whose length is in element [0]
define acopyl(*a__[],b__[]){
  .=acopyr(a__[],b__[],0,a__[0])
}

# Copy first 'count' elements of a from b
define acopy(*a__[],b__[],count){
  auto i;
  if(count<0)count=0;
  if(count>max_array_)count=max_array_+1;
  for(i=0;i<count;i++)a__[i]=b__[i];return 0
}

## Convert between array types ##

define aconv0fromr(*a__[],  b__[],start,end){
  auto i,j;
  .=asanerange_();
  i=0;for(j=start;j<=end;j++)a__[i++]=b__[j]
  a__[i]=0
}
define aconvbfromr(*a__[],x,b__[],start,end){
  auto i,j;
  .=asanerange_();
  i=0;for(j=start;j<=end;j++)a__[i++]=b__[j]
  a__[i]=x
}
define aconvlfromr(*a__[],  b__[],start,end){
  auto i,j;
  .=asanerange_();
  i=1;for(j=start;j<=end;j++)a__[i++]=b__[j]
  a__[0]=end-start+1
}

define aconvrfrom0(*a__[],start,end,b__[]){
  auto i,j;
  .=asanerange_();
  j=0;for(i=start;i<=end&&b__[j];i++)a__[i]=b__[j++]
}
define aconvbfrom0(*a__[],x,        b__[]){
  auto i;
  for(i=0;a__[i]=b__[i];i++){}
  a__[i]=x
}
define aconvlfrom0(*a__[],          b__[]){
  auto i,j;
  i=1;j=0;while(a__[i++]=b__[j++]){}
  a__[0]=j
}

define aconv0fromb(*a__[],          b__[],x){
  auto i;
  for(i=0;(a__[i]=b__[i])!=x;i++){}
  a__[i]=0
}
define aconvrfromb(*a__[],start,end,b__[],x){
  auto i,j;
  .=asanerange_();
  j=0;for(i=start;i<=end&&b__[j]!=x;i++)a__[i]=b__[j++]
}
define aconvlfromb(*a__[],          b__[],x){
  auto i,j;
  i=1;j=0;while((a__[i++]=b__[j++])!=x){}
  a__[0]=j
}

define aconvrfroml(*a__[],start,end,b__[]){
  auto i,j;
  .=asanerange_();
  j=1;for(i=start;i<=end&&j<=b__[0];i++)a__[i]=b__[j++]
}
define aconv0froml(*a__[],          b__[]){
  auto i,j;
  i=0;j=1;while(j<=b__[0])a__[i++]=b__[j++];
  a__[i]=0;
}
define aconvbfroml(*a__[],x,        b__[]){
  auto i,j;
  i=0;j=1;while(j<=b__[0])a__[i++]=b__[j++];
  a__[i]=x;
}

## Copy in a small number of elements ##

define aset8(*a__[],start,a,b,c,d,e,f,g,h){
  auto b[];
  b[0]=a;b[1]=b;b[2]=c;b[3]=d
  b[4]=e;b[5]=f;b[6]=g;b[7]=h
  .=acopy2r(a__[],start,start+7,b[],0,7)
}

define aset16(*a__[],start,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){
  auto b[];
  b[0]=a;b[1]=b;b[2]=c;b[3]=d
  b[4]=e;b[5]=f;b[6]=g;b[7]=h
  b[8]=i;b[9]=j;b[A]=k;b[B]=l
  b[C]=m;b[D]=n;b[E]=o;b[F]=p
  .=acopy2r(a__[],start,start+F,b[],0,F)
}

## Append one array to another ##

define aappendr(*a__[],aend,b__[],bstart,bend) {
  auto i,j;
  if(aend>max_array_)aend=max_array_;
  if(bstart>bend){j=bstart;bstart=bend;bend=j}
  if(bstart<0)bstart=0;
  if(bend>max_array_)bend=max_array_;
  j=bstart;
  for(i=aend+1;i<=max_array_&&j<=bend;i++)a__[i]=b__[j++]
}

define aappend0(*a__[],b__[]) {
  auto i,j;
  for(i=0;i<=max_array_&&a__[i];i++){}
  if(i>max_array_)return 0;
  for(j=0;i<=max_array_&&b__[j];j++)a__[i++]=b__[j]
  if(i>max_array_)return 0;
  a__[i]=0;
}

define aappendb(*a__[],b__[],x) {
  auto i,j;
  for(i=0;i<=max_array_&&a__[i]!=x;i++){}
  if(i>max_array_)return 0;
  for(j=0;i<=max_array_&&b__[j]!=x;j++)a__[i++]=b__[j]
  if(i>max_array_)return 0;
  a__[i]=x;
}

define aappendl(*a__[],b__[]) {
  .=aappendr(a__[],a__[0],b__[],1,b__[0])
  a__[0]+=b__[0]
}

define aappend(*a__[],aend,b__[],count) {
  return aappendr(a__[],aend,b__[],0,count-1)
}

define aappendelem0(*a__[],e) {
  auto i;
  for(i=0;i<=max_array_&&a__[i];i++){}
  if(i>max_array_)return 0;
  a__[i++]=e;
  if(i>max_array_)return 0;
  a__[i]=0;
}

define aappendelemb(*a__[],x,e) {
  auto i;
  for(i=0;i<=max_array_&&a__[i]!=x;i++){}
  if(i>max_array_)return 0;
  a__[i++]=e;
  if(i>max_array_)return 0;
  a__[i]=x;
}

define aappendelem(*a__[],aend,e) {
  if(++aend>max_array_)return 0;
  a__[aend]=e;return 0
}

define aappendeleml(*a__[],e) {
  if(++a__[0]>max_array_){a__[0]=max_array_;return 0}
  a__[a__[0]]=e
}

## part a, part b, part c

define aparts3r(*a__[],astart,aend,b__[],bstart,bend,c__[],cstart,cend) {
  auto i,j;
  .=asanerange2_();
  if(cstart>cend){i=cstart;cstart=cend;cend=i}
  if(cstart<0)cstart=0;
  if(cend>max_array_)cend=max_array_;
  i=0;
  if(astart>0)for(j=astart;j<aend;j++)if(i++<=max_array_)a__[i]=a__[j];
  for(j=bstart;j<bend;j++)if(i++<=max_array_)a__[i]=b__[j];
  for(j=cstart;j<cend;j++)if(i++<=max_array_)a__[i]=c__[j];
}

## Insertion of elements and other arrays ##

define ainsertatr(*a__[],astart,aend,pos,b__[],bstart,bend){
  auto i;
  .=asanerange2_();
  if(pos>aend-astart)return aappendr(a__[],aend,b__[],bstart,bend);
  if(pos<=0){
    .=aappendr(b__[],bend,a__[],astart,aend);
    .=acopyr(a__[],b__[],bstart,aend-astart+bend)
    return 0;
  }
  .=aparts3r(a__[],astart,astart+pos-1,b__[],bstart,bend,a__[],astart+pos,aend);
}

define ainsertat0(*a__[],pos,b__[]){
  auto i,j,alen,blen;
  for(i=0;i<=max_array_&&b__[i];i++){}
  blen=i
  for(i=0;i<=max_array_&&a__[i];i++){}
  alen=i
  if(pos>=alen)return aappend0(a__[],b__[]);
  if(pos<0)pos=0;
  for(--i;i>=pos;i--){
    if((j=blen+i)>max_array_)continue;
    a__[j]=a__[i]
  }
  for(i=0;i<blen;i++){
    if((j=pos+i)>max_array_)continue;
    a__[j]=b__[i]
  }
  a__[alen+blen]=0
}
define ainsertatb(*a__[],pos,b__[],x){
  auto i,j,alen,blen;
  for(i=0;i<=max_array_&&b__[i]!=x;i++){}
  blen=i
  for(i=0;i<=max_array_&&a__[i]!=x;i++){}
  alen=i
  if(pos>=alen)return aappend0(a__[],b__[]);
  if(pos<0)pos=0;
  for(--i;i>=pos;i--){
    if((j=blen+i)>max_array_)continue;
    a__[j]=a__[i]
  }
  for(i=0;i<blen;i++){
    if((j=pos+i)>max_array_)continue;
    a__[j]=b__[i]
  }
  a__[alen+blen]=x
}
define ainsertatl(*a__[],pos,b__[]){
  auto i;
  if(pos>a__[0])return aappendl(a__[],b__[]);
  if(pos<1)pos=1;
  for(i=a__[0];i>=pos;i--){
    if((j=b__[0]+i)>max_array_)continue;
    a__[j]=a__[i]
  }
  for(i=1;i<=b__[0];i++){
    if((j=pos+i-1)>max_array_)continue;
    a__[j]=b__[i]
  }
  a__[0]+=b__[0]
}
define ainsertat(*a__[],acount,pos,b__[],bcount){
  return ainstertatr(a__[],0,acount-1,pos,b__[],0,bcount-1);
}

define ainsertelematr(*a__[],start,end,pos,e){
  auto b[];b[0]=e
  return ainsertatr(a__[],start,end,pos,b[],0,0);
}
define ainsertelemat0(*a__[],pos,e){
  auto b[];b[0]=e;b[1]=0
  return ainsertat0(a__[],pos,b[]);
}
define ainsertelematb(*a__[],x,pos,e){
  auto b[];b[0]=e;b[1]=x
  return ainsertatb(a__[],pos,b[],x);
}
define ainsertelematl(*a__[],pos,e){
  auto b[];b[0]=1;b[1]=e
  return ainsertatl(a__[],pos,b[]);
}
define ainsertelemat(*a__[],count,pos,e){
  auto b[];b[0]=e
  return ainstertatr(a__[],0,count-1,pos,b[],0,0);
}

## Comparison -> Lexical ##

# Compare a__[astart..aend] and b__[bstart..bend]
define acompare2r(a__[],astart,aend,b__[],bstart,bend){
  auto a,b,i,j;
  .=asanerange2_();
  i=astart;j=bstart;
  while(i<=aend&&j<=bend){
    a=a__[i++];b=b__[j++]
    if(a<b)return -1;
    if(a>b)return  1;
  }
  if(i>aend&&j>bend)return 0;#sub arrays are equivalent
  if(i>aend)return -1;#left array is shorter
  return 1;#right array is shorter
}

# Compare a__[start..end] and b__[start..end]
define acomparer(a__[],b__[],start,end){
  auto i;
  .=asanerange_();
  for(i=start;i<=end;i++){
    if(a__[i]<b__[i])return -1;
    if(a__[i]>b__[i])return  1;
  }
  return 0;
}

# compare zero-terminated arrays; a <=> b
define acompare0(a__[],b__[]) {
  auto i;
  for(i=0;i<=max_array_&&a__[i]&&b__[i];i++){
    if(a__[i]<b__[i])return -1;
    if(a__[i]>b__[i])return  1;
  }
  if(i>max_array_||(a__[i]==0&&b__[i]==0))return 0;
  if(a__[i]==0)return -1;#left array is shorter
  return 1;
}

# compare x terminated arrays; a <=> b
define acompareb(a__[],b__[],x) {
  auto i;
  for(i=0;i<=max_array_&&a__[i]!=x&&b__[i]!=x;i++){
    if(a__[i]<b__[i])return -1;
    if(a__[i]>b__[i])return  1;
  }
  if(i>max_array_||(a__[i]==x&&b__[i]==x))return 0;
  if(a__[i]==x)return -1;#left array is shorter
  return 1;
}

# compare length-specified arrays; a <=> b
define acomparel(a__[],b__[]) {
  auto i;
  for(i=1;i<=max_array_&&i<=a__[0]&&i<=b__[0];i++){
    if(a__[i]<b__[i])return -1;
    if(a__[i]>b__[i])return  1;
  }
  if(i>max_array_||(i>a__[0]&&i>b__[0]))return 0;
  if(i>a__[0])return -1;#left array is shorter
  return 1;
}

# Compare first 'count' elements of a and b
define acompare(a__[],b__[],count){
  auto i;
  if(count<0)count=0;
  if(count>max_array_)count=max_array_+1;
  for(i=0;i<count;i++){
    if(a__[i]<b__[i])return -1;
    if(a__[i]>b__[i])return  1;
  }
  return 0;
}

## Comparison -> Equality ##

# Check equality of a__[astart..aend] and b__[bstart..bend]
define   aequals2r(a__[],astart,aend,b__[],bstart,bend){
return !acompare2r(a__[],astart,aend,b__[],bstart,bend)}

# Check equality of a__[start..end] and b__[start..end]
define   aequalsr(a__[],b__[],start,end){
return !acomparer(a__[],b__[],start,end)}

# Check equality of zero-terminated arrays; a == b
define   aequals0(a__[],b__[]){
return !acompare0(a__[],b__[])}

# Check equality of x terminated arrays; a == b
define   aequalsb(a__[],b__[],x){
return !acompareb(a__[],b__[],x)}

# Check equality of length specified arrays; a == b
define   aequalsl(a__[],b__[]){
return !acomparel(a__[],b__[])}

# Check equality of first 'count' elements of a and b
define   aequals(a__[],b__[],count){
return !acompare(a__[],b__[],count)}

## Subarray matching ##

# Returns position in large that first occurrence of small is found
# . or -1 if no match is found
define amatcharray2r(small__[],astart,aend,large__[],bstart,bend){
  auto i,j;
  .=asanerange2_();
  if(aend-astart>bend-bstart)return -1;
  i=astart;j=bstart;
  while(j<=bend){
    while(         j<=bend&&small__[i]!=large__[j]){.=j++}
    if(j>bend)return -1;
    .=i++   ;.=j++
    while(i<=aend&&j<=bend&&small__[i]==large__[j]){.=i++;.=j++}
    if(i>aend)return j-aend+astart-1;
    i=astart;.=j++
  }
  return -1;
}

# As above but large and small are zero terminated arrays
define amatcharray0(small__[],large__[]){
  auto i,j;
  for(i=0;i<=max_array_&&small__[i];i++){}
  for(j=0;j<=max_array_&&large__[j];j++){}
  if(i>j)return -1;
  return amatcharray2r(small__[],0,i-1,large__[],0,j-1)
}

# As above but large and small are arrays terminated by x
define amatcharrayb(small__[],large__[],x){
  auto i,j;
  for(i=0;i<=max_array_&&small__[i]!=x;i++){}
  for(j=0;j<=max_array_&&large__[j]!=x;j++){}
  if(i>j)return -1;
  return amatcharray2r(small__[],0,i-1,large__[],0,j-1)  
}

# As above but large and small are arrays terminated by x
define amatcharrayl(small__[],large__[]){
  if(small__[0]>large__[0])return -1;
  return amatcharray2r(small__[],1,small__[0],large__[],1,large__[0])  
}

define amatcharray(small__[],scount,large__[],lcount){
  if(scount>lcount) return -1;
  return amatcharray2r(small__[],0,scount-1,large__[],0,lcount-1);
}

## Single element finding ##

define amatchelementr(e,a__[],start,end){
  auto i;
  .=asanerange_();
  for(i=start;i<=end;i++)if(a__[i]==e)return i;
  return -1;
}

define amatchelement0(e,a__[]){
  auto i;
  for(i=0;i<=max_array_&&a__[i];i++)if(a__[i]==e)return i;
  if(i<=max_array_&&e==0)return i; 
  return -1;
}

define amatchelementb(e,a__[],x){
  auto i;
  for(i=0;i<=max_array_&&a__[i]!=x;i++)if(a__[i]==e)return i;
  if(i<=max_array_&&e==x)return i;
  return -1;
}

define amatchelementl(e,a__[]){
  auto i;
  for(i=1;i<=max_array_&&i<=a__[0];i++)if(a__[i]==e)return i;
  return -1;
}

define amatchelement(e,a__[],count){
  return amatchelementr(e,a__[],0,count-1);
}

## Output ##

aprint_wide_=1

# Prints a__[start..end]
define aprintr(*a__[],start,end) {
  auto i;
  if(start>end){print"{}";return 0}
  .=asanerange_();
  print "{";for(i=start;i<end;i++){
    print a__[i],", ";if(!aprint_wide_)print"\n "
  };print a__[i],"}\n"
}

# Treats a__[] as a zero terminated array; prints all elements prior to 0
define aprint0(*a__[]) {
  auto e,f,i;
  print "{";
  if(!(e=a__[i=0])){print "}\n";return 0}
  while(++i<=max_array_&&f=a__[i]){
    print e,", "
    if(!aprint_wide_)print"\n "
    e=f;
  }
  print e,"}\n"
}

# Treats a__[] as an 'x' terminated array; prints all elements [b]efore 'x'
define aprintb(*a__[],x) {
  auto e,f,i;
  print "{";
  if(x==(e=a__[i=0])){print "}\n";return 0}
  while(++i<=max_array_&&(f=a__[i])!=x){
    print e,", "
    if(!aprint_wide_)print"\n "
    e=f;
  }
  print e,"}\n"
}

# Treats a__[] as an 'x' terminated array 
# . but prints all elements [u]pto and including 'x'
define aprintu(*a__[],x) {
  auto i;
  print "{";
  for(i=0;a__[i]!=x&&i<max_array_;i++) {
    print a__[i],", "
    if(!aprint_wide_)print"\n "
  }
  if(i==max_array_){print a__[i]}else{print x}
  print "}\n"
}

# Treats a__[] as a length specified array and prints it
define aprintl(*a__[]) {
  auto e,f,i;
  if(a__[0]==0){print"{}";return 0}
  print "{";
  for(i=1;i<a__[0];i++) {
    print a__[i],", "
    if(!aprint_wide_)print"\n "
  }
  print a__[i],"}\n"
}

# Prints the first 'count' elements of a__[]
define aprint(*a__[],count) {
 .=aprintr(a__[],0,count-1)
}

#from http://phodd.net/gnu-bc/code/cf.bc
### CF.BC - Continued fraction experimentation using array pass by reference
###A suite of functions for basic continued fraction analysis. Uses the undocumented pass-by-reference feature of arrays where necessary.
###    Continued fractions
###    Rational approximation
###    Upscale / increase rational number accuracy 
# Best usage for the output functions in this library:
#   .=output_function(params)+newline()
# This suppresses the output and also appends a newline which is not added
# by default.

## Initialisation / Tools / Workhorses ##

# Borrowed from funcs.bc
define int(x) { auto os;os=scale;scale=0;x/=1;scale=os;return(x) }
define abs(x) { if(x<0)return(-x)else return(x) }

# Borrowed from output_formatting.bc
define newline() { print "\n" }

# sanity check for the below
define check_cf_max_() {
  auto maxarray;
  maxarray = 4^8-4;cf_max=int(cf_max)
  if(1>cf_max||cf_max>maxarray)cf_max=maxarray
  return 0;
}

# global var; set to halt output and calculations at a certain point
cf_max=-1; # -1 to flag to other libs that cf.bc exists before value is set

# Workhorse function to prepare for and tidy up after CF generation
define cf_tidy_(){
  # POSIX scope; expects vars cf__[], max, p and i
  # Tidy up the end of the CF
  #  assumes the last element of large CFs to be invalid due to rounding
  #    and deletes that term.
  #  for apparently infinite (rather than just long) CFs, uses a bc trick
  #    to signify special behaviour to the print functions.
  #  for apparently finite CFs, checks whether the CF ends ..., n, 1]
  #  which can be simplified further to , n+1]
  auto j,diff,rl,maxrl,bestdiff
  cf__[i]=0
  if(p>max){
    .=i--;
    if(p<max*A^5){ # assume infinite
      cf__[i]=0.0; # bc can tell between 0 and 0.0
      # Identify repeating CFs and store extra information
      #  that is used by the print functions.
      max=i;mrl=0;
      p=max-1;if((i=p-1)>0)for(i=i;i;i--){
        if(cf__[i]==cf__[p]){
          diff=p-i;rl=0
          for(j=p-1;j>diff;j--){if(cf__[j-diff]!=cf__[j])break;.=rl++}
          if(j<=i)rl+=diff
          if(rl>mrl){mrl=rl;bestdiff=diff}
        }
      }
      if(3*mrl>=p){cf__[++max]=p-mrl-1;cf__[++max]=bestdiff;cf__[0]+=0.0}
      return 0;
    }
    cf__[i]=0; # bc can differentiate between 0 and 0.0
  } 
  if(i<2)return 0;
  .=i--;if(abs(cf__[i])==1){cf__[i-1]+=cf__[i];cf__[i]=0}
  return 0;
}

# Workhorse function for cf_new and cfn_new
define cf_new_(near) {
  # POSIX scope; expects array *cf__[] and var x
  auto os, i, p, max, h, n, temp;
  .=check_cf_max_()
  os=scale;if(scale<scale(x))scale=scale(x)
  if(scale<6+near){
    print "cf";if(near)print"n";print"_new: scale is ",scale,". Poor results likely.\n"
  }
  max=A^int(scale/2);p=1
  if(near)h=1/2;
  for(i=0;i<cf_max&&p<max;i++) {
    if(near){
      n=int(temp=x+h);if(n>temp).=n-- # n=floor(x+.5)
    } else {
      n=int(x)
    }
    p*=1+abs(cf__[i]=n);
    x-=cf__[i]
    if(x==0||p==0){.=i++;break}
    x=1/x
  }
  scale=os
  return cf_tidy_();
}

## Making/unmaking continued fractions and ordinary fractions ##

# Create a continued fraction representation of x in pbr array cf__[]
define cf_new(*cf__[],x) {
  return x+cf_new_(0);
}

# Create a continued fraction representation of x in pbr array cf__[]
# using signed terms to guarantee largest magnitude following term
define cfn_new(*cf__[],x) { 
  return x+cf_new_(1);
}

# Copy a continued fraction into pbr array cfnew__[] from pbv array cf__[]
define cf_copy(*cfnew__[],cf__[]){
  auto e,i;
  for(i=0;i<=cf_max&&e=cf__[i];i++)cfnew__[i]=e
  if(i<=cf_max)cfnew__[i]=cf__[i] # might be 0.0
  e=cf__[0];if(int(e)==e&&scale(e)){
    # copy extra info
    if(++i<=cf_max)cfnew__[i]=cf__[i]
    if(++i<=cf_max)cfnew__[i]=cf__[i]
  }
  return (i>cf_max);
}

# Convert pbv array cf__[] into a number
define cf_value(cf__[]) {
  auto n, d, temp, i;
  .=check_cf_max_();
  if(cf__[1]==0)return cf__[0];
  for(i=1;i<cf_max&&cf__[i];i++){}
  n=cf__[--i];d=1
  for(i--;i>=0;i--){temp=d;d=n;n=temp+cf__[i]*d}
  return(n/d);
}

# Convert pbv array cf__[] into a new cf of the other type
# . with respect to nearness.
define cf_toggle(*cf__[],cf2__[]){
  auto os,p,i,x,zero,sign,near;
  sign=1;if(cf2__[0]<0)sign=-1
  near=0
  for(i=1;x=cf2__[i];i++){
    p*=1+abs(x)
    if(x*sign<0)near=1
  }
  zero=x;
  os=scale;scale=0
   for(i=2;p;i++)p/=A
   if(i<os)i=os
  scale=i
   x=cf_value(cf2__[])
   .=cf_new_(1-near)
  scale=os
  for(i=0;cf__[i];i++){}
  cf__[i]=zero;
  return 0
}

# Return the value of the specified convergent of a CF
define cf_get_convergent(cf__[],c){
  auto ocm,v;
  if(c==0)return cf_value(cf__[]);
  .=check_cf_max_();ocm=cf_max
  cf_max=c;v=cf_value(cf[])
  cf_max=ocm;return v;
}

# Return the value of the specified convergent of the CF of x
define get_convergent(x,c){
  auto cf[];
  .=cf_new(cf[],x)
  return cf_get_convergent(cf[],c)
}

# Create denominator, numerator and optional intpart in
# . first three elements of pbr array f__[]
# . from CF in pbv array cf[]()
# NB: returned elements are in reverse of the expected order!
define frac_from_cf(*f__[],cf__[],improper) {
  auto n,d,i,temp;
  .=check_cf_max_();
  improper=!!improper;
  if(cf__[0]==(i=int(cf__[0])))cf__[0]=i
  if(cf__[1]==0){f__[0]=1;f__[1]=0;return f__[2]=cf__[0]}
  for(i=1;i<cf_max&&cf__[i];i++){}
  n=cf__[--i];d=1
  for(i--;i>=!improper;i--){
    temp=n;n=d;d=temp # reciprocal = swap numerator and denominator
    n+=cf__[i]*d
  }
  temp=0
  if(!improper){temp=n;n=d;d=temp}#correct for having stopped early
  if(d<0){n=-n;d=-d} # denominator always +ve
  if(!improper&&cf__[0]!=0){
    temp=cf__[0]
  }
  f__[0]=d;f__[1]=n;f__[2]=temp
  return temp+n/d;
}

# Upscale an allegedly rational number to the current scale
define upscale_rational(x) {
  auto os,f[],cf[];
  if(scale<=scale(x))return x
  os=scale;scale=scale(x)
  .=cf_new(cf[],x);          # Sneaky trick to upscale (literally)
  .=frac_from_cf(f[],cf[],1) # any rational value of x
  scale=os
  x=f[1]/f[0] # x is now (hopefully) double accuracy!
  return x;
}

## Output ##

# Set to 1 to truncate quadratic surd output before repeat occurs
cf_shortsurd_=0

# Output pbv array cf__[] formatted as a CF
define cf_print(cf__[]) {
  auto i,sign,surd,sli,sri;
  .=check_cf_max_();
  sign=1;if(cf__[0]<0||(cf__[0]==0&&cf__[1]<0)){sign=-1;print "-"}
  # Check for surd flag and find lead in and repeat period
  surd=0;sri=int(i=cf__[0]);if(scale(i)&&sri==i){
    for(i=1;cf__[i];i++){}
    sli=cf__[++i]
    surd=cf__[++i]
  }
  print "[", sign*sri;
  if(cf__[1]==0){print "]";return 0}
  print "; ";
  if(surd)if(sli){sri=sli-1}else{sri=surd-1}
  for(i=2;i<=cf_max&&cf__[i];i++){
    print sign*cf__[i-1]
    if(!surd||sri){
      print ", ";if(surd).=sri--
    } else {
      if(sli){
        sli=0
      }else if(cf_shortsurd_){print ";...]";return 0}
      print "; ";sri=surd-1
    }
  }
  print sign*cf__[i-1];
  # detect a 0.0 which signifies that the cf has been determined
  # to be infinite (not 100% accurate, but good)
  if(scale(cf__[i])){
    if(!surd||sri){print ","}else{print ";"}
    print "..."
  }
  print "]";
  return (i>cf_max);
}

# Print a number as a continued fraction
define print_as_cf(x) {
  auto cf[];
  .=cf_new(cf[],x)+cf_print(cf[])
  return x;
}

# Print a number as a signed continued fraction
define print_as_cfn(x) {
  auto cf[];
  .=cfn_new(cf[],x)+cf_print(cf[])
  return x;
}

# Output pbv array cf__[] as a fraction or combination of int and fraction
# . the 'improper' parameter makes the choice.
# . . set to non-zero for top-heavy / improper fractions
define cf_print_frac(cf__[],improper) {
  auto f[],v;
  v=frac_from_cf(f[],cf__[],improper)
  if(f[1]==0){print f[2];return f[2]}
  if(!improper&&cf__[0]!=0){
    print cf__[0]
    if((f[1]<0)==(f[0]<0)){print"+"} # if n and d have same sign...
  }
  print f[1],"/",f[0] # n/d
  return v;
}

# Print x as a fraction or combination of int and fraction
# . the 'improper' parameter makes the choice.
# . . set to non-zero for top-heavy / improper fractions
define print_frac(x,improper) {
  auto cf[]
  .=cf_new(cf[],x)+cf_print_frac(cf[],improper)
  return x;
}

# Print x as a fraction or combination of int and fraction
# . the 'improper' parameter makes the choice.
# . . set to non-zero for top-heavy / improper fractions
# . This alternative function rounds to the nearest integer
# . . for the integer part and then shows the addition
# . . or _subtraction_ of the fraction.
# . . e.g. 1+2/3 is shown as 2-1/3
define print_frac2(x,improper) {
  auto cf[];
  .=cfn_new(cf[],x)+cf_print_frac(cf[],improper)
  return x;
}

define cf_print_convergent(cf__[],c){
  auto ocm,n,v;
  if(c==0)return cf_print_frac(cf__[],0);
  if(c<0){n=1;c=-c}else{n=c}
  .=check_cf_max_();ocm=cf_max;
  for(n=n;n<=c;n++){cf_max=n;v=cf_print_frac(cf__[],1);if(n!=c)print "\n"}
  cf_max=ocm;return v;
}

define print_convergent(x,c){
  auto cf[],v;
  v=cf_new(cf[],x)
  v=cf_print_convergent(cf[],c)
  return v;
}

#from http://phodd.net/gnu-bc/code/cf_engel.bc
### CF_ENGEL.BC - Engel expansion experimentation using array pass by reference
###Functions for generating, printing and interpreting Engel Expansions in a similar manner to ordinary continued fractions. Sister library to cf_sylvester.bc
###    Engel Expansions
###    Infinite Egyptian Fraction 
# Workhorse: Create an Engel expansion of x in pbr array en__[]
define engel_new_(mode) {
  # expects *en__[] and x to be declared elsewhere
  auto i,fc,max,q,p
  
  # error checking
  .=check_cf_max_()
  p=(mode<1&&abs(x)>=1);
  q=(scale<6);
  if(p||q){print "engel";if(mode==-1)print "fall";if(mode==0)print "alt";print "_new: "}
  if(p){print "Can't work with integer part.\n"; x-=int(x)}
  if(q){print "scale is ",scale,". Poor results likely.\n"}
  
  max=A^scale
  i=fc=0;p=1
  for(i=0;x&&p<max&&i<cf_max;i++){
    q=1/abs(x)
    if(mode==1){
      q=ceil(q) # proper engel expansion
    } else if(mode==-1){
      q=floor(q) # secondary engel expansion
    } else if(fc=!fc){q=floor(q)}else{q=ceil(q)} # tertiary engel expansion
    p*=q
    en__[i]=q*=sgn(x)
    x=x*q-1
  }
  if(p>=max){
    if(!--i)i=1
    max=A^int(scale/2)
    if(abs(en__[i])>max){
      en__[i]=0;return 0
    }else{
      en__[i]=0.0
      if(i-=2<3)return 0;
      q=en__[i]
      if(en__[--i]==q){
        while(en__[i--]==q){}
        en__[i+3]=0
        .=en__[i+2]--
      }
    }
  }else{
    en__[i]=0
  }
  return 0;
}

# Create Engel expansion of x in pbr array en__[]
# . all terms same sign as x
define engel_new(*en__[],x) {
  return x+engel_new_(1);
}

# Create secondary Engel expansion of x in pbr array en__[]
# . first term same sign as x, all other terms opposite sign
# . terms in implied Egyptian fraction sum have alternating signs
define engelfall_new(*en__[],x) {
  return x+engel_new_(-1);
}

# Create tertiary Engel expansion of x in pbr array en__[]
# . first term same sign as x, following terms alternate in sign
# . terms in implied Egyptian fraction alternate pairwise e.g. +--++--++...
define engelalt_new(*en__[],x) {
  return x+engel_new_(0);
}

# Output pbv array en__[] formatted as an Engel expansion
define engel_print(en__[]){
  auto i;
  .=check_cf_max_();
  print "{";
  if(en__[1]==0){print en__[0],"}";return 0}
  for(i=1;en__[i];i++)print en__[i-1],", ";
  print en__[i-1];
  if(scale(en__[i]))print ",...";
  print "}";return 0;
}

# Print a number as an Engel expansion
define print_as_engel(x){
  auto en[];
  .=engel_new(en[],x)+engel_print(en[])
  return x;
}
define print_as_engelfall(x){
  auto en[];
  .=engelfall_new(en[],x)+engel_print(en[])
  return x;
}
define print_as_engelalt(x){
  auto en[];
  .=engelalt_new(en[],x)+engel_print(en[])
  return x;
}

# Turn the Engel expansion in pbv array en__[] into its value
define engel_value(en__[]) {
  auto i,p,v;
  .=check_cf_max_();
  p=1;v=0;for(i=0;i<cf_max&&p*=en__[i];i++)v+=1/p
  return v;
}

#from http://phodd.net/gnu-bc/code/cf_sylvester.bc
### CF_SYLVESTER.BC - Sylvester expansion experimentation using array pass by reference
### Functions for generating, printing and interpreting Sylvester Expansions in a similar manner to ordinary continued fractions. Sister library to cf_engel.bc
###    Greedy Egyptian fractions
###    Sylvester Expansions 
# Workhorse: Create an Sylvester expansion of x in pbr array sy__[]
define sylvester_new_(mode) {
  # expects *sy__[] and x to be declared elsewhere
  auto i,max,q,iq,p,h
  
  # error checking
  .=check_cf_max_()
  #p=(abs(x)>=1);
  q=(scale<6);
  #if(p||q){print "sylvester";if(mode)print "2";print "_new: "}
  #if(p){print "Can't work with integer part.\n"; x-=int(x)}
  if(q){print "scale is ",scale,". Poor results likely.\n"}
  
  max=A^int(scale/2)
  i=0;p=1;h=3/2
  for(i=0;x&&p<max&&i<cf_max;i++){
    q=1/abs(x)
    if(!mode){
      q=ceil(q) # proper sylvester expansion
    } else {
      q=floor(q+h) # secondary sylvester expansion
    }
    p*=q
    sy__[i]=q*=sgn(x)
    x-=1/q
  }
  if(p>=max){
    if(!mode)if(!--i)i=1
    if(abs(sy__[i])>max){
      sy__[i]=0;.=i--
      while(iq=int(q=(sy__[i]*sy__[i-1])/(sy__[i]+sy__[i-1]))==q){
        sy__[i]=0;sy__[--i]=iq
      }
    }else{
      sy__[i]=0.0
    }
  }else{
    sy__[i]=0
  }
  return 0;
}
#echo 'scale=250;sylvester_new(a[],7/15);.=sylvester_print(a[])+newline();sylvester_value(a[])' | bc -l funcs.bc *.bc


# Create Sylvester expansion of x in pbr array sy__[]
# . all terms same sign as x
define sylvester_new(*sy__[],x) {
  return x+sylvester_new_(0);
}

# Create secondary Sylvester expansion of x in pbr array sy__[]
# . first term same sign as x, all other terms opposite sign
# . terms in implied Egyptian fraction sum have alternating signs
define sylvester2_new(*sy__[],x) {
  return x+sylvester_new_(1);
}

# Output pbv array sy__[] formatted as an Sylvester expansion
define sylvester_print(sy__[]){
  auto i;
  .=check_cf_max_();
  print "{";
  if(sy__[1]==0){print sy__[0],"}";return 0}
  for(i=1;sy__[i];i++)print sy__[i-1],", ";
  print sy__[i-1];
  if(scale(sy__[i]))print ",...";
  print "}";return 0;
}

# Print a number as an Sylvester expansion
define print_as_sylvester(x){
  auto sy[];
  .=sylvester_new(sy[],x)+sylvester_print(sy[])
  return x;
}
define print_as_sylvester2(x){
  auto sy[];
  .=sylvester2_new(sy[],x)+sylvester_print(sy[])
  return x;
}

# Turn the Sylvester expansion in pbv array sy__[] into its value
define sylvester_value(sy__[]) {
  auto i,p,n,d;
  .=check_cf_max_();
  n=0;d=1;for(i=0;i<cf_max&&p=sy__[i];i++){n=n*p+d;d*=p}
  return n/d;
}

### from http://phodd.net/gnu-bc/code/cf_misc.bc
### CF_MISC.BC - Miscellaneous functions separated from CF.BC
## CF Alteration ##
# Take the absolute value of all terms in pbv array cf__[]
# . WARNING: This irrevocably changes the array!
define cf_abs_terms(*cf__[]) {
  auto i,t,changed;
  .=check_cf_max_();
  changed=0;
  for(i=0;i<cf_max&&cf__[i];i++){
    t=cf__[i];if(t<0){t=-t;changed=1}
    cf__[i]=t
  }
  return changed;
}

# Take the absolute value, less 1, of all terms in pbv array cf__[]
# . WARNING: This irrevocably changes the array!
define cf_abs1_terms(*cf__[]) {
  auto i,err;
  .=check_cf_max_();
  for(i=0;i<cf_max&&cf__[i];i++)
    if(0==(cf__[i]=abs(cf__[i])-1)){err=1;break}
  if(err){
    print "abs1_cf error: invalid cf for this transformation. truncation occurred\n";
  }
  return err;
}

# Return the value of a CF as if all terms are positive
define cf_value_abs(cf__[]) {
  auto cp[];
  .=cf_copy(cp[],cf__[])+cf_abs_terms(cp[])
  return cf_value(cp[])
}

# Return the value of a CF as if all terms are positive and reduced by 1
define cf_value_abs1(cf__[]) {
  auto cp[];
  .=cf_copy(cp[],cf__[])+cf_abs1_terms(cp[])
  return cf_value(cp[])
}

# Convert x through the cfn and abs transformations
# . and return the value of the resultant CF
define cfn_flip_abs(x) {
  auto cf[];
  .=cfn_new(cf[],x)+cf_abs_terms(cf[])
  return cf_value(cf[])
}

# Convert x through the cfn and abs1 transformations
# . and return the value of the resultant CF
define cfn_flip_abs1(x) {
  auto cf[];
  .=cfn_new(cf[],x)+cf_abs1_terms(cf[])
  return cf_value(cf[])
}

## Binary RLE <--> CF conversion ##

# Minkowski Question Mark function - Inverse of Conway Box
# . Treat the fractional part of x as a CF and transform it into a
# . representation of alternating groups of bits in a binary number
define cf_question_mark(cf__[]) {
  auto os,n,i,b,x,t,tmax,sign,c;
  .=check_cf_max_();
  tmax=A^scale
  sign=1;if(cf__[0]<0)sign=-1
  b=0;t=1
  for(i=1;i<cf_max&&cf__[i]&&t<tmax;i++){
    if((c=cf__[i]*sign)<0){
      print "question_mark_cf: terms not absolute values. aborting\n"
      return 0;
    }
    for(j=c;j&&t<tmax;j--){x+=b/t;t+=t}
    b=!b
  }
  os=scale
  if(t<tmax){
    c=0;while(t>1){.=c++;t/=A}
    scale=c
  }
  x=(cf__[0]+sign*x)/1;
  scale=os
  return upscale_rational(x);
}

# As above but only generates a CF as intermediary
define question_mark(x) { # returns ?(x)
  auto cf[];
  .=cf_new(cf[],x)
  return cf_question_mark(cf[])
}

# Conway Box function - Inverse of Minkowski Question Mark
# . Transform the fractional part of x by making a CF from a run-length
# . encoding of the binary digits, and using that as the new fractional part
define cf_conway_box(*cf__[],x) { # cf__[] = [[_x_]]
  auto os,f[],max,p,i,b,bb,n,j,ix,sign,which0;
  os=scale;scale+=scale
  x=upscale_rational(x)
  max=A^os;p=1
  sign=1;if(x<0){sign=-1;x=-x}
  x-=(b=int(x));cf__[0]=sign*b
  b=0
  n=1;j=1
  for(i=0;i<=cf_max&&i<scale;i++){
    x+=x;bb=int(x)
    if(bb==b){.=n++}else{cf__[j++]=sign*n;p*=1+n;n=1}
    b=bb;x-=b
  }
  if(n){cf__[j++]=sign*n;p*=1+n}
  i=j;while(!i).=i--;.=i++
  scale=os
  return cf_tidy_();
}

# As above but only generates a CF as intermediary
define conway_box(x) {
  auto os,f[],cf[];
  .=cf_conway_box(cf[],x)
  return cf_value(cf[])
}

###from http://phodd.net/gnu-bc/code/collatz.bc
### Collatz.BC - The 3x+1 or hailstones problem
###A suite of functions for very basic experimentation with the Collatz conjecture. All functions here use the global variable collatz_mode_ to determine which Collatz ruleset is to be used. By default this is set to 1 and the rules are the standard Collatz rules of:
###    even x → x/2, odd x → 3x+1. 
### When set to 2, the rules become the condensed rules:
###     even x → x/2, odd x → (3x+1)/2. 
### When set to zero, the rules become:
###     even x → oddpart(x), odd x → oddpart(3x+1), where oddpart is what remains of a number when it is divided by 2 until it cannot be divided further. 
# Global variable
# The original Collatz iteration has rules:
#   odd  x -> 3x+1
#   even x -> x/2
# The condensed Collatz iteration has rules:
#   odd  x -> (3x+1)/2
#   even x -> x/2
# ...since the usual odd step always produces an even value
# The odd-only Collatz iteration has rules:
#   odd  x -> odd part of 3x+1
#   even x -> odd part of x
# This var sets the mode of the functions in this library
#   0 =>  odd-only Collatz
#   1 =>  original Collatz - note that these two entries ...
#   2 => condensed Collatz - ... match the divisor on the odd step
collatz_mode_=1

# sanity check
define check_collatz_mode_() {
  auto os;
  if(collatz_mode_==0||collatz_mode_==1||collatz_mode_==2)return collatz_mode_
  if(collatz_mode_<0||collatz_mode_>2)collatz_mode_=1
  if(scale(collatz_mode_)){os=scale;scale=0;collatz_mode_/=1;scale=os}
  return collatz_mode_
}

## Step forwards and back


# Generate the next hailstone
define collatz_next_(x) {
  auto os,t;
  os=scale;scale=0;x/=1
  t=x/2;if(x!=t+t)t=3*x+1
  if(collatz_mode_){
    if(collatz_mode_==2&&t>x){x=t/2}else{x=t}
  } else {
    while(x==t+t||t>x){x=t;t/=2}
  }
  scale=os;return x
}

define collatz_next(x) {
  .=check_collatz_mode_()
  return collatz_next_(x)
}

# Take a guess at the previous hailstone - since in some cases there are
# two choices, this function always chooses the option of lowest magnitude
define collatz_prev(x) {
  auto os,a,b,c;
  os=scale;scale=0;x/=1
  if(check_collatz_mode_()){
    a=collatz_mode_*x-1;b=a/3
    x+=x
    if(3*b!=a||b==1||b==-1){scale=os;return x}
    if((b>0)==(b<x))x=b
  } else {
    # oddonly mode shouldn't really return an even number
    #  but when x is even or divisible by three, there _is_
    #  no previous odd hailstone, so an even number must suffice.
    if(!x%2||!x%3){scale=os;return x+x}
    for(a=1;1;a+=a){
      b=a*x-1;c=b/3
      if(3*c==b){b=c/2;if(c!=b+b){scale=os;return c}}
    }
  }
  scale=os;return x
}

## Chain examination

max_array_ = 4^8

# Determine whether an integer, x, reaches 1 under the Collatz iteration
# . defined for both positive and negative x, so will
# . return 0 under some circumstances!
define is_collatz(x) {
  auto os,t,i,tape[],tapetop
  os=scale;scale=0;x/=1
  if(x==0){scale=os;return 0}
  .=check_collatz_mode_()
  tapetop=-1
  while(x!=1&&x!=-1){
    t = collatz_next_(x)
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){scale=os;return 0}
    if(tapetop++>max_array_){
      print "is_collatz: can't calculate; chain too long. assuming true.\n"
      scale=os;return 1
    }
    tape[tapetop]=x=t
  }
  return x
}

# Print the chain of iterations of x until a loop or 1
# . was cz_chain
define collatz_print(x) {
  auto os,t,i,tape[],tapetop
  os=scale;scale=0;x/=1
  x;if(x==0){scale=os;return 0}
  .=check_collatz_mode_()
  tapetop=-1
  while(x!=1&&x!=-1){
    t = collatz_next_(x)
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){scale=os;"looping ";return t}
    if(tapetop++>max_array_){
      print "collatz_print: can't calculate; chain too long.\n"
      scale=os;return t
    }
    tape[tapetop]=x=t;t
  }
}

# Find the number of smallest magnitude under the Collatz iteration of x
# . assuming the conjecture is true, this returns 1 for all positive x
define collatz_root(x) {
  auto os,t,i,tape[],tapetop
  os=scale;scale=0;x/=1
  if(x==0){scale=os;return 0}
  .=check_collatz_mode_()
  tapetop=-1
  while(x!=1&&x!=-1){
    t = collatz_next_(x)
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){
      #go back the other way looking for the lowest absolute value
      while(++i<=tapetop)if((tape[i]>0)==(tape[i]<t))t=tape[i]
      scale=os;return t
    }
    if(tapetop++>max_array_){
      print "collatz_print: can't calculate; chain too long.\n"
      scale=os;return (x>0)-(x<0)
    }
    tape[tapetop]=x=t
  }
  return x
}

# Returns the loopsize should the iteration become stuck in a loop
# . assuming the conjecture is true, this returns 3 for the
# . 4,2,1,4,etc. loop for all positive x.
define collatz_loopsize(x) {
  auto os,t,i,tape[],tapetop
  os=scale;scale=0;x/=1
  if(x==0){scale=os;return 1}
  .=check_collatz_mode_()
  tapetop=-1
  while(x!=1&&x!=-1){
    t = collatz_next_(x)
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){scale=os;return tapetop-i+1}
    if(tapetop++>max_array_){
      print "collatz_loopsize: can't calculate; chain too long.\n"
      scale=os;return 0
    }
    tape[tapetop]=x=t
  }
  if(collatz_mode_==0)return 1
  if(collatz_mode_==1)return 3
  if(collatz_mode_==2)return 2
}

# How many iterations to 1 (or loop)?
define collatz_chainlength(x) {
  auto os,t,i,c,tape[],tapetop
  os=scale;scale=0;x/=1
  if(x==0){scale=os;return 0}
  .=check_collatz_mode_()
  tapetop=-1
  while(x!=1&&x!=-1){
    .=c++
    t = collatz_next_(x)
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){scale=os;return 2-c }# infinity
    if(tapetop++>max_array_){
      print "collatz_chainlength: can't calculate; chain too long.\n"
      scale=os;return -c
    }
    tape[tapetop]=x=t
  }
  return c
}

# Highest point on way to 1 or before being stuck in a loop
define collatz_magnitude(x) {
  auto os,t,i,m,tape[],tapetop
  os=scale;scale=0;x/=1
  if(x==0){scale=os;return 0}
  .=check_collatz_mode_()
  tapetop=-1
  m=x
  while(x!=1&&x!=-1){
    t = collatz_next_(x)
    if((t>0)==(t>m))m=t
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){scale=os;return m}
    if(tapetop++>max_array_){
      print "collatz_magnitude: can't calculate; chain too long.\n"
      scale=os;return m
    }
    tape[tapetop]=x=t
  }
  return m
}

# Sum of all values in the iteration
define collatz_sum(x) {
  auto os,t,i,s,tape[],tapetop
  os=scale;scale=0;x/=1
  if(x==0){scale=os;return 0}
  .=check_collatz_mode_()
  tapetop=-1
  s=x
  while(x!=1&&x!=-1){
    t = collatz_next_(x)
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){scale=os;"infinite ";return 0}
    if(tapetop++>max_array_){
      print "collatz_sum: can't calculate; chain too long.\n"
      scale=os;return s
    }
    tape[tapetop]=x=t
    s+=t
  }
  return s
}

# is_collatz_sg(x) # set globals by name of above functions

# All of the above rolled into one.
# Global variables are set with the same names as the above functions
# with the exception of global variable collatz_print, which should be
# set to non-zero if emulation of the collatz_print() function is required
define is_collatz_sg(x) {
  auto os,t,i,s,c,m,tape[],tapetop
  os=scale;scale=0;x/=1
  if(collatz_print)x
  if(x==0){
    collatz_root        = 0
    collatz_loopsize    = 1
    collatz_chainlength = 0
    collatz_magnitude   = 0
    collatz_sum         = 0
    scale=os;return 0
  }
  .=check_collatz_mode_()
  tapetop=-1
  s=m=x
  while(x!=1&&x!=-1){
    .=c++
    t = collatz_next_(x)
    if((t>0)==(t>m))m=t
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){
      collatz_loopsize    = tapetop-i+1
      collatz_chainlength = 2-c # Infinite
      collatz_magnitude   = m
      collatz_sum         = 0   # Infinite
      #go back the other way looking for the lowest absolute value
      while(++i<=tapetop)if((tape[i]>0)==(tape[i]<t))t=tape[i]
      collatz_root        = t
      scale=os;return 0
    }
    if(tapetop++>max_array_){
      print "is_collatz_sg: can't calculate; chain too long.\n"
      collatz_root        = (x>0)-(x<0)
      collatz_loopsize    = 0
      collatz_chainlength = -c
      collatz_magnitude   = m
      collatz_sum         = s
      scale=os;return s
    }
    tape[tapetop]=x=t
    if(collatz_print)x
    s+=t
  }
  collatz_root        = x
  if(collatz_mode_==0) collatz_loopsize = 1
  if(collatz_mode_==1) collatz_loopsize = 3
  if(collatz_mode_==2) collatz_loopsize = 2
  collatz_chainlength = c
  collatz_magnitude   = m
  collatz_sum         = s
  return x
}


###from http://phodd.net/gnu-bc/code/collatz_continuous.bc
### Collatz_Continuous.BC - Attempt to extend the Collatz iteration to
###                         all real numbers
###Most functions in this library have two versions; One which relies on the global collatz_mode_ variable as described in collatz.bc and another which has a secondary parameter for otherwise specifying the power of two of the divisor (if any) on the odd step. See notes in code for more details.
###Each of the non-inverse functions is designed to provide a continuous version of the single Collatz iteration function. This necessarily means that each of mappings has fixed points at certain non-integer values of their first parameter. i.e. x = f(x)
# For functions with the k parameter:
#  always return x/2 for even x
#  for k=0,     returns 3x+1 for odd x [Standard Collatz]
#  for k=1,     returns (3x+1)/2 for odd x [First Simplification]
#  for k=other, returns (3x+1)/(k+1) for odd x [Side effect]
#  i.e. for integers, return the same as for collatz_next() in
#    collatz.bc
#  for x=non integer, interpolates between odd and even values

# cosine interpolation
define collatz_cos_(x,k) { return x/2+(1-cos(pi()*x))/2*((3*x+1)/pow(2,k)-x/2) }
define collatz_cos(x) { 
  if(!check_collatz_mode_())return 0
  return collatz_cos_(x,collatz_mode_-1)
}

# as above but performs true linear interpolation
define collatz_lin_(x,k) {
  auto l,p,a,b
  l=floor(x);p=l-2*floor(l/2)
  if(l==x)if(p){
    return (3*x+1)/pow(2,k)
  } else {
    return x/2
  }
  if(p){
    a=(3*l+1)/pow(2,k);b=(l+1)/2
  } else {
    a=l/2;b=(3*l+4)/pow(2,k)
  }
  return a+(x-l)*(b-a)
}
define collatz_lin(x) {
  if(!check_collatz_mode_())return 0
  return collatz_lin_(x,collatz_mode_-1)
}

# as above but performs pseudo-linear interpolation
define collatz_linb_(x,k) { return x/2+(1-abs(1-x+2*floor(x/2)))*((3*x+1)/pow(2,k)-x/2) }
define collatz_linb(x) {
  if(!check_collatz_mode_())return 0
  return collatz_linb_(x,collatz_mode_-1)
}

# as above but performs piecewise cosine interpolation
define collatz_pcos_(x,k) {
  auto l,p,a,b
  l=floor(x);p=l-2*floor(l/2)
  if(l==x)if(p){
    return (3*x+1)/pow(2,k)
  } else {
    return x/2
  }
  x=(1-cos(pi()*x))/2
  if(p){
    a=(3*l+1)/pow(2,k);b=(l+1)/2
    x=1-x
  } else {
    a=l/2;b=(3*l+4)/pow(2,k)
  }
  return a+x*(b-a)
}
define collatz_pcos(x) {
  if(!check_collatz_mode_())return 0
  return collatz_pcos_(x,collatz_mode_-1)
}

## Inverse functions

# Workhorse for invlin and arcpcos.
define collatz_piecewise__(y,k) {
  # Assumes a,b,ca,cb,t,s,x are POSIXly defined elsewhere
  a=(pow(2,k)*y-1)/3;b=y+y
  if((y>0)==(a>b)){t=a;a=b;b=t}
  s=1;if(a<0)s=-1
  t=s*floor(s*b);a=s*ceil(s*a)
  ca=collatz_lin_(a,k);cb=collatz_lin_(t,k)
  x=0
  if(y==ca)return x=a
  if(y==cb)return x=b
  cb=collatz_lin_(b=a+s,k)
  while(b*s<=t*s){
    if(y==cb){x=b;break}
    if((ca<y&&y<cb)||(cb<y&&y<ca)){x=1;break}
    ca=cb;a=b;b+=s;cb=collatz_lin_(b,k)
  }
  if(y<0){t=a;a=b;b=t; t=ca;ca=cb;cb=t}
}

# Attempt to find a solution to y=collatz_lin_(x,k) for x
# . Where y is integer, finds a valid Collatz inverse
#   Otherwise finds solution with smallest magnitude
define collatz_invlin_(y,k) {
  auto a,b,ca,cb,t,s,x
  if(y==0)return 0
  if(y==-1||y==1)return y*2^k
  .=collatz_piecewise__(y,k)
  if(cb==ca)return 2*y/1
  if(x==1)x=(y-ca)/(cb-ca)+a
  return x
}
define collatz_invlin(y) {
  if(!check_collatz_mode_())return 0
  return collatz_invlin_(y,collatz_mode_-1)
}

# Attempt to find a solution to y=collatz_pcos_(x,k) for x
# . Where y is integer, finds a valid Collatz inverse
#   Otherwise finds solution with smallest magnitude
define collatz_arcpcos_(y,k) {
  auto a,b,ca,cb,t,s,x
  if(y==floor(y))return collatz_invlin_(y,k)
  .=collatz_piecewise__(y,k)
  if(x!=1)return x
  x=(y-ca)/(cb-ca);x=1-x-x
  x=arccos(x)/pi()+a
  return x
}
define collatz_arcpcos(y) {
  if(!check_collatz_mode_())return 0
  return collatz_arcpcos_(y,collatz_mode_-1)
}

# TO DO: improve the following further

# Attempt to find a solution to y=collatz_cos_(x,k) for x
define collatz_arccos_(y,k) {
  auto os,x,t,d,nd,v,eps;
  if(y==floor(y))return collatz_invlin_(y,k)
  os=scale;eps=A^-os;scale+=length(y)-scale(y)+1
  x=collatz_arcpcos_(y,k) # got to start somewhere
  if(x==floor(x))x-=eps
  v=1/4;d=1
  while(d>eps&&v){
    t=collatz_cos_(x-v,k)
    nd=abs(t-y)
    if(nd>d){
      t=collatz_cos_(x+v,k)
      nd=abs(t-y)
      if(nd>d){nd=d}else{x+=v}
    }else{x-=v}
    d=nd;v/=2
  }
  scale=os;return x/1
}
define collatz_arccos(y) {
  if(!check_collatz_mode_())return 0
  return collatz_arccos_(y,collatz_mode_-1)
}

# Attempt to find a solution to y=collatz_linb_(x,k) for x
define collatz_invlinb_(y,k) {
  auto os,x,t,d,nd,v,eps;
  if(y==floor(y))return collatz_invlin_(y,k)
  os=scale;eps=A^-os;scale+=length(y)-scale(y)+1
  x=collatz_invlin_(y,k) # got to start somewhere
  if(x==floor(x))x-=eps
  v=1/4;d=1
  while(d>eps&&v){
    t=collatz_linb_(x-v,k)
    nd=abs(t-y)
    if(nd>d){
      t=collatz_linb_(x+v,k)
      nd=abs(t-y)
      if(nd>d){nd=d}else{x+=v}
    }else{x-=v}
    d=nd;v/=2
  }
  scale=os;return x/1
}
define collatz_invlinb(y) {
  if(!check_collatz_mode_())return 0
  return collatz_invlinb_(y,collatz_mode_-1)
}

### from http://phodd.net/gnu-bc/code/complex.bc
### Complex.BC - Rudimentary complex number handling for GNU BC
### A second attempt at creating and working with complex numbers in bc. Uses arrays and the undocumented pass-by-reference feature to store the real and imaginary parts of a number. The downside to this method is that the syntax is somewhat unwieldy: When a complex return value is required, the first parameter is always *c__[] and the return value is stored within the first two elements of the supplied array, rather than being returned in the usual bc way.
###Some 'constants' are predefined by this library; These are complex0[], complex1[], complex2[], complexi[], complexomega[] and complexomega2[]. These are zero, one, two, imaginary unit i and roots of positive unity ω and ω2. 

  ## Not to be regarded as suitable for any purpose
  ## Not guaranteed to return correct answers

# Uses the undocumented pass-by-reference method for arrays
# Uses arrays to store complex and imaginary parts

# Most functions are of the form f(*c, otherparams) meaning c = f(otherparams)

# Code can be somewhat unwieldy
# e.g. .= makecomplex(a[],1,2) sets a[] to be the complex number 1+2i

# Non-trivial example: To find the absolute value of the arc-cosine of 1+2i
# i.e. |arccos(1+2i)|, use: .=makecomplex(a[],1,2)+carccos(a[],a[]);cabs(a[])
# ".=" is a bc trick to suppress output of function values
# the "+" sign is used because it is shorter than ";.="
#   i.e. end of statement and further output suppression
# carccos(a[],a[]) means a = arccos(a)
#   n.b. the first a[] is passed by reference, the second is by value
# cabs() is used on its own as it returns a proper bc number

# make a complex number from real and imaginary parts
define makecomplex(*c__[],r,i) {
  c__[0]=r;c__[1]=i
}

.= makecomplex(complex0[],0,0)
.= makecomplex(complex1[],1,0)
.= makecomplex(complex2[],2,0)
.= makecomplex(complexi[],0,1)

define makeomega() {
  auto mh,hs3
  mh=-1/2;hs3=sqrt(3)/2
  .= makecomplex(complexomega[] ,mh, hs3)
  .= makecomplex(complexomega2[],mh,-hs3)
}
.= makeomega()

## Arrays - can't have an array of arrays in bc so workarounds required

define carrayget(*c__[],a__[],i) { # c = a[i]
  c__[0] = a__[i+=i]
  c__[1] = a__[i+=1]
}

define carrayset(*a__[],i,c__[]) { # a[i] = c
  a__[i+=i] = c__[0]
  a__[i+=1] = c__[1]
}

## Useful basics

# copy right hand parameter's contents into left; i.e. c = x
define cassign(*c__[],x__[]) {
  c__[0]=x__[0];c__[1]=x__[1]
}

# Assign the complex conjugate of a complex number; c = x*
define cconj(*c__[],x__[]) {
  c__[0]=x__[0];c__[1]=-x__[1]
}

# Turn a complex into its own conjugate
define cconjself(*c__[]) {
  c__[1]=-c__[1]
}

# Negate a complex; i.e. c*=-1
define cnegself(*c__[]) {
  c__[0]=-c__[0]
  c__[1]=-c__[1]
}

# assign the negative of the right hand side to the left; c = -x
define cneg(*c__[],x__[]) {
  c__[0]=-x__[0]
  c__[1]=-x__[1]
}

# Extract the real part; Re c
define real(c__[]) {
  return c__[0]
}

# Extract the imaginary part; Im c
define imag(c__[]) {
  return c__[1]
}

# Calculates the absolute value of a complex number; |c|
# NB: returns a standard bc number and not a new fangled 'complex'
define cabs(c__[]) {
  return sqrt(c__[0]^2+c__[1]^2)
}

# Print a generated complex number
define printc(c__[]) {
  auto r,i
  r = c__[0]
  i = c__[1]
  print r
  if(i<0){print " -";i=-i}else{print " +"}
  print " i*",i,"\n"
}

## Boolean

define cequal(a__[],b__[]) {
  return (a__[0]==b__[0])&&(a__[1]==b__[1])
}

## Basic math

# Add two complex numbers; c = a + b
define cadd(*c__[],a__[],b__[]) {
  c__[0]=a__[0]+b__[0]
  c__[1]=a__[1]+b__[1]
}

define caddassign(*c__[],b__[]) { # c += b
  c__[0]+=b__[0]
  c__[1]+=b__[1]
}

# Subtract a complex number from another; c = a - b
define csub(*c__[],a__[],b__[]) {
  c__[0]=a__[0]-b__[0]
  c__[1]=a__[1]-b__[1]
}

define csubassign(*c__[],b__[]) { # c -= b
  c__[0]-=b__[0]
  c__[1]-=b__[1]
}

# Multiply two complex, return complex; c = a * b
define cmul(*c__[],a__[],b__[]) {
  c__[0]=a__[0]*b__[0]-a__[1]*b__[1]
  c__[1]=b__[0]*a__[1]+a__[0]*b__[1]
}

define cmulassign(*c__[],b__[]) { # c *= b
  auto a__[];
  return cassign(a__[],c__[])+cmul(c__[],a__[],b__[])
}

# Divide one complex by another, returning a third
define cdiv(*c__[],a__[],b__[]) {
  auto aa;
  aa = b__[0]^2+b__[1]^2
  c__[0]=(a__[0]*b__[0]+a__[1]*b__[1])/aa
  c__[1]=(b__[0]*a__[1]-a__[0]*b__[1])/aa
}

define cdivassign(*c__[],b__[]) { # c /= b
  auto a__[];
  return cassign(a__[],c__[])+cdiv(c__[],a__[],b__[])
}

## Basic Math II - fast[er] squaring, square roots and integer power

# Square a complex number; c = x^2
define csquare(*c__[],x__[]) {
  c__[0]=x__[0]^2-x__[1]^2
  c__[1]=2*x__[0]*x__[1]
}

define csquareself(*c__[]) { # c*=c or c^=2
  auto a__[];
  return cassign(a__[],c__[])+csquare(c__[],a__[]) # a = c; c = a^2
}

# Find the primary square root of a complex number; c = sqrt(x)
define csqrt(*c__[],x__[]) {
  auto r,i, sr, si
  if(x__[1]==0){if(x__[0]>=0){
    c__[0]=sqrt(x__[0]);c__[1]=0
    return;
  } else {
    c__[0]=0;c__[1]=sqrt(-x__[0])
    return;
  }}
  c__[0] = sqrt((sqrt(x__[0]^2+x__[1]^2)+x__[0])/2)
  c__[1] = x__[1]/c__[0]/2
}

define csqrtself(*c__[]) { # c = sqrt(c)
  auto a__[];
  return cassign(a__[],c__[])+csqrt(c__[],a__[]) # a = c; c = sqrt(a)
}

# subfunctions for use by cintpow
define mod(n,m) {auto s;s=scale;scale=0;n%=m;scale=s;return(n)}
define int(n)   {auto s;s=scale;scale=0;n/=1;scale=s;return(n)}

# Raise a complex number [z] to an integer power [n]
# NB: n is a standard bc number and not a complex
define cintpow(*c__[], z[], n) { # c = z^n
  n = int(n)
  if(n<0) { 
    .= cintpow(c__[], z[], -n); # c = z^-n
    .= cdiv(c__[], complex1[], c__[]);   # c = 1/c
    return;
  }
  if(n==0)return( cassign(c__[],one[]) ) ; # c = 1
  if(n==1)return( cassign(c__[],  z[]) ) ; # c = z^1 == z
  if(n==2)return( csquare(c__[],  z[]) ) ; # c = z^2
  .= cassign(c__[],complex1[]) ; # c = 1
  while(n) { 
    if(mod(n,2)) {
      .= cmulassign(c__[], z[]) # c *= z
      n -= 1
    } else {
      .= csquareself(z[])
      n = int(n/2)
    }
  }
}

define cintpowassign(*c__[],n) { # c ^= n
  auto a__[];
  return cassign(a__[],c__[])+cintpow(c__[],a__[],n) # a = c; c = sqrt(a)
}

## Other

# find the sign; c = sgn(x) = x/|x|
define csgn(*c__[],x__[]) {
  auto aa;
  if(x__[0]==0&&x__[1]==0) return c__[0]=c__[1]=0;
  aa = cabs(x__[]);
  c__[0]=x__[0]/aa;c__[1]=x__[1]/aa
}

define csgnself(*x__[]) { # x /= |x|
  auto aa;
  if(x__[0]==0&&x__[1]==0) return;
  aa = cabs(x__[]);
  x__[0]/=aa;x__[1]/=aa
}

# Arctangent (two real arguments)
# . borrowed from funcs.bc
define arctan2(x,y) { 
  auto p;
  if(x==0&&y==0)return(0)
  p=((y<0)+1-(y>0))*2*a(1)*(2*(x>=0)-1)
  if(x==0||y==0)return(p)
  return(p+a(x/y))
}

# Argument of complex number; returns standard bc number
define carg(c__[]) {
  return arctan2(c__[1],c__[0])
}

# cos + i sin -> cis; x is a standard bc number
# . for complex x see ccis()
define cis(*c__[],x) {
  c__[0] = c(x)
  c__[1] = s(x)
}

## Exponentials

define cln(*c__[],x__[]) { # c = ln(x) == l(x)
  c__[0] = l(cabs(x__[]))
  c__[1] = carg(x__[])
}

define clnself(*c__[]) { # c = ln(x) == l(x)
  auto t;
  t = carg(c__[])
  c__[0] = l(cabs(c__[]))
  c__[1] = t
}

define cexp(*c__[],x__[]) { # c = exp(x) == e(x)
  auto e;
  e = e(x__[0])
  c__[0] = e*c(x__[1])
  c__[1] = e*s(x__[1])
}

define cexpself(*c__[]) { # c = exp(c) == e(c)
  auto e;
  e = e(c__[0])
  c__[0] = e*c(c__[1])
  c__[1] = e*s(c__[1])
}

define cpow(*c__[],a__[],b__[]) { # c = a^b
  .= printc
  .= clnself(a__[])          # a = ln(a)
  .= cmulassign(a__[],b__[]) # a *= b
  .= cexp(c__[],a__[])       # c = exp(a) == e(a)
}

define cpowassign(*c__[],b__[]) { # c ^= b
  .= clnself(c__[])          # c = ln(c)
  .= cmulassign(c__[],b__[]) # c *= b
  .= cexpself(c__[])         # c = exp(c) == e(c)
}

## Trig

define csin(*c__[],x__[]) {
  auto e,em;
  e=e(x__[1]);em=1/e
  c__[0]=(e+em)/2*s(x__[0])
  c__[1]=(e-em)/2*c(x__[0])
}

define ccos(*c__[],x__[]) {
  auto e,em;
  e=e(x__[1]);em=1/e
  c__[0]=(em+e)/2*c(x__[0])
  c__[1]=(em-e)/2*s(x__[0])
}

define ctan(*c__[],x__[]) {
  auto e,em,d;
  x__[0]+=x__[0];x__[1]+=x__[1]
  e=e(x__[1]);em=1/e
  d=c(x__[0])+(e+em)/2
  c__[0]=s(x__[0])/d
  c__[1]=(e-em)/(d+d)
}

define ccis(*c__[],x__[]) {
  auto e;
  e = e(-x__[1])
  c__[0]=c(x__[0])*e
  c__[1]=s(x__[0])*e
}

define ccosec(*c__[],x__[]) {
  return csin(c__[],x__[]) + cdiv(c__[],complex1[],c__[]) # c = sin(x); c = 1/c
}

define csec(*c__[],x__[]) {
  return ccos(c__[],x__[]) + cdiv(c__[],complex1[],c__[]) # c = cos(x); c = 1/c
}

define ccotan(*c__[],x__[]) {
  return ctan(c__[],x__[]) + cdiv(c__[],complex1[],c__[]) # c = tan(x); c = 1/c
}

define csinh(*c__[],x__[]) {
  auto e,em;
  e = e(x__[0]);em=1/e
  c__[0]=(e-em)/2*c(x__[1])
  c__[1]=(e+em)/2*s(x__[1])
}

define ccosh(*c__[],x__[]) {
  auto e,em;
  e = e(x__[0]);em=1/e
  c__[0]=(em-e)/2*c(x__[1])
  c__[1]=(em+e)/2*s(x__[1])
}

define ctanh(*c__[],x__[]) {
  auto e,em,d;
  x__[0]+=x__[0];x__[1]+=x__[1]
  e=e(x__[0]);em=1/e
  d=c(x__[1])+(e+em)/2
  c__[0]=(e-em)/(d+d)
  c__[1]=s(x__[1])/d
}

define ccosech(*c__[],x__[]) {
  return csinh(c__[],x__[]) + cdiv(c__[],complex1[],c__[]) # c = sinh(x); c = 1/c
}

define csech(*c__[],x__[]) {
  return ccosh(c__[],x__[]) + cdiv(c__[],complex1[],c__[]) # c = cosh(x); c = 1/c
}

define ccotanh(*c__[],x__[]) {
  return ctanh(c__[],x__[]) + cdiv(c__[],complex1[],c__[]) # c = tanh(x); c = 1/c
}

# Inverse Trig

define carcsin(*c__[],x__[]) {
  .= cmul(c__[],complexi[],x__[]) # c = i*x
  .= csquareself(x__[])           # x = x^2
  .= csub(x__[],complex1[],x__[]) # x = 1-x
  .= csqrtself(x__[])             # x = sqrt(x)
  .= caddassign(c__[],x__[])      # c += x
  .= clnself(c__[])               # c = ln(c)
  .= cmulassign(c__[],complexi[]) # c *= i
  .= cnegself(c__[])              # c = -c
}

define carccos(*c__[],x__[]) {
  .= cmul(c__[],complexi[],x__[]) # c = i*x
  .= csquareself(x__[])           # x = x^2
  .= csub(x__[],complex1[],x__[]) # x = 1-x
  .= csqrtself(x__[])             # x = sqrt(x)
  .= caddassign(c__[],x__[])      # c += x
  .= clnself(c__[])               # c = ln(c)
  .= cmulassign(c__[],complexi[]) # c *= i
     c__[0] += 2*a(1)             # c += pi/2
}

define carctan(*c__[],x__[]) {
  .= cmulassign(x__[],complexi[]) # x *= i
  .= csub(c__[],complex1[],x__[]) # c = 1-x
  .= caddassign(x__[],complex1[]) # x += 1
  .= clnself(c__[])               # c = ln(c)
  .= clnself(x__[])               # x = ln(x)
  .= csubassign(c__[],x__[])      # c -= x
  .= cmulassign(c__[],complexi[]) # c *= i
     c__[0]/=2;c__[1]/=2          # c /= 2
}

define carccis(*c__[],x__[]) {
  .= cassign(c__[],x__[])    # c = x
  .= csquareself(c__[])      # c ^= 2
     c__[0] += 1             # c += 1
  .= caddassign(x__[],x__[]) # x += x == x *= 2
  .= cdivassign(c__[],x__[]) # c /= x
  .= carccos(c__[],c__[])    # c = arccos(c)
}

define carccosec(*c__[],x__[]){
  .= cdiv(x__[],complex1[],x__[]) # x = 1/x
  .= carcsin(c__[],x__[])         # c = arcsin(x)
}

define carcsec(*c__[],x__[]){
  .= cdiv(x__[],complex1[],x__[]) # x = 1/x
  .= carccos(c__[],x__[])         # c = arccos(x)
}

define carccotan(*c__[],x__[]){
  .= cdiv(x__[],complex1[],x__[]) # x = 1/x
  .= carctan(c__[],x__[])         # c = arctan(x)
}

define carcsinh(*c__[],x__[]) {
  .= cassign(c__[],x__[])    # c = x
  .= csquareself(x__[])      # x = x^2
     x__[0] += 1             # x += 1
  .= csqrtself(x__[])        # x = sqrt(x)
  .= caddassign(c__[],x__[]) # c += x
  .= clnself(c__[])          # c = ln(c)
}

define carccosh(*c__[],x__[]) {
  .= cassign(c__[],x__[])    # c = x
  .= csquareself(x__[])      # x = x^2
     x__[0] -= 1             # x -= 1
  .= csqrtself(x__[])        # x = sqrt(x)
  .= caddassign(c__[],x__[]) # c += x
  .= clnself(c__[])          # c = ln(c)
}

define carctanh(*c__[],x__[]) {
  .= cassign(c__[],x__[])         # c = x
     c__[0] += 1                  # c += 1
  .= csub(x__[],complex1[],x__[]) # x = 1-x
  .= clnself(c__[])               # c = ln(c)
  .= clnself(x__[])               # x = ln(x)
  .= csubassign(c__[],x__[])      # c -= x
     c__[0]/=2;c__[1]/=2          # c /= 2
}

define carccosech(*c__[],x__[]){
  .= cdiv(x__[],complex1[],x__[]) # x = 1/x
  .= carcsinh(c__[],x__[])        # c = arcsinh(x)
}

define carcsech(*c__[],x__[]){
  .= cdiv(x__[],complex1[],x__[]) # x = 1/x
  .= carccosh(c__[],x__[])        # c = arccosh(x)
}

define carccotanh(*c__[],x__[]){
  .= cdiv(x__[],complex1[],x__[]) # x = 1/x
  .= carctanh(c__[],x__[])        # c = arctanh(x)
}


###from http://phodd.net/gnu-bc/code/cosconst.bc
# cosconst = rootof(x = cos(x))
### The cosine constant to a large number of decimal places, where x = cos(x) 
cosconst=\
.7390851332151606416553120876738734040134117589007574649656806357732\
84654883547594599376106931766531849801246643987163027714903691308420\
31578044057462077868852490389153928943884509523480133563127677223158\
09563537765724512043734199364335125384097800343406467004794021434780\
80271801883771136138204206631633503727799169673122323006138865820362\
17708109978970626842405880948986832618606004858989585487257367640150\
75227608180391459518101628159120096461646067544051326415171064466281\
10936082584878371383955556175141494715939006277527563258634938869730\
14083665152511520426788515302529417180365176420177086071899276016098\
74327154552267565798246297611775539616699549311158566534834953838523\
15963602527499558725250666640131318740139253888805520618698592139252\
52854154110791002998282929864052169046554736696871438735646006521225\
46891499759209699758501364249508565047324972584248371554836483437275\
83746752545335800664200478839718858489014531155060417812337047773953\
4717103451195854600726561464721419787537388023680

/*
  scale=1000;pi_2=a(1)*2
  for(scale=10;scale<=1000;scale+=5){
    eps=A^(1-scale);p=pi_2/1
    oc=0;while(abs(oc-c)>eps){
      oc=c;s=s(c+p);c=(c+s+s)/3
    }
    c
  }
*/

### from http://phodd.net/gnu-bc/code/digits.bc
### Digits.BC - Treat numbers as strings of digits
### Treat numbers as strings of digits. Some of the definitions below are not in strict alphabetical order. This is so that concepts are introduced in a more logical order.
### Many functions will operate with bijective (zero-less) number bases, which can be activated through use of the new global bijective flag. By default this is zero. Set to non-zero to alter the behaviour of those functions which support it.
### Some functions operate correctly with negative number bases, e.g. negabinary.
###     Digital sum
###     Reverse
###     Palindromes
###     Stringification
###     Cantor reinterpretation
###     Bijective (zero-less) numeration
###     Negative integer bases (negabase) 

bijective=0
# Returns x mod y, but sets 0 mod y to be y itself in bijective mode
# . Old version: define bmod_(x,y) { if(bijective){return (x-1)%y+1}else{return x%y} }
# . This version sets a global variable called bdiv_ containing the result
# . . of the complementary division
define bmod_(x,y) { return x-y*(bdiv_=(x-=bijective)/y); }

# Workhorse function - use POSIX scope to check
# . 'base' parameter of many functions here
define base_check_() {
  if(base<2-(bijective=!!bijective)){
    if(base<=-2){
      print "Negative bases not currently supported; "
    } else if(base==-1||base==0||base==1) {
      print "Nonsense base: ",base,"; "
    }
    print "Using ibase instead.\n"
    base=ibase
  }
}

# Number of digits in the base representation of x
# (compare the int_log function in funcs.bc)
define digits(base,x) { 
 auto os,p,c;
 os=scale;scale=0;base/=1;x/=1
  if(x<0)x=-x
  .=base_check_()
  if(bijective&&base==1){scale=os;return x}
  if(x==0){scale=os;return !bijective}
  if(bijective)x=x*(base-1)+1
  if(x<base){scale=os;return(1)}
  c=length(x) # cheat and use what bc knows about decimal length
  if(base==A){scale=os;return c-bijective}
  if(base<A){
   if(x>A){c*=(digits(base,A)-1);if(base<4)c-=2}else{c=0}
  }else{
   c/=length(base)
  }
  p=base^c
  while(p<=x){.=c++;p*=base}
 scale=os;return(c-bijective)
}

# Sum of digits in a number: 1235 -> 11 in base ten
define digit_sum(base,x) {
 auto os,t;
 os=scale;scale=0;base/=1;x/=1
  .=base_check_()
  t=0;while(x){t+=bmod_(x,base);x=bdiv_}
 scale=os;return(t)
}

# Workhorse for the next two functions
define digit_distance_(base,x,y,sh) {
  auto os,sgn,dx,dy,d,t;
  os=scale;scale=0;base/=1;x/=1;y/=1
  if(x==y||x==-y){scale=os;return 0}
  if(x==0||y==0){scale=os;return digit_sum(base,x+y)}
  .=base_check_()
  sign=1
  if(x<0){x=-x;sign=-sign}
  if(y<0){y=-y;sign=-sign}
  t=0;
  while(x||y){
    dx=bmod_(x,base);x=bdiv_
    dy=bmod_(y,base);y=bdiv_
    d=dx-dy
    if(d<0)d=-d;if(sh)if(d+d>base)d=base-d
    t+=d
  }
  scale=os;return sign*t
}

# Digit distance between two numbers:
# . e.g. 746(-)196 -> |7-1|+|4-9|+|6-6| = 6+5+0 = 11 in base ten
# . Degenerates to digit_sum if either of x or y is zero
# . Not equivalent to hamming distance
# . + which merely counts the number of differences
# . . See logic_otherbase.bc for hamming distance function
define digit_distance(base,x,y) {
  return digit_distance_(base,x,y,0)
}

# Digit distance between two numbers assuming shortest path modulo
#  the given base, e.g. shortest distance between 2 and 8 mod ten is 4
# . e.g. 746((-))196 -> 4 + 5 + 0 = 9 base ten
define digit_sdistance(base,x,y) {
  return digit_distance_(base,x,y,1)
}

# Product of digits in number
# e.g. 235 -> 2*3*5 = 30 in base ten
# . see digits_misc.bc for two alternatives to this function
define digit_product(base,x) { 
 auto os,t;
 if(x<0)return digit_product(base,-x);
 os=scale;scale=0;base/=1;x/=1
  .=base_check_()
  t=1;while(x&&t){t*=bmod_(x,base);x=bdiv_}
 scale=os;return(t)
}

# Reverse the digits in x using given base
define reverse(base,x) {
 auto os,y;
 os=scale;scale=0;base/=1;x/=1
  .=base_check_()
  y=0;while(x){y=base*y+bmod_(x,base);x=bdiv_}
 scale=os;return(y) 
}

## Palindromes

# Determine if x is a palindrome in the given base
define is_palindrome(base,x){
 if(x<0)x=-x
 return reverse(base,x)==x
}

# Determine if x is a pseudopalindrome in the given base
# - a pseudopalindrome is a number that could be a palindrome
#   if a number of zeroes is prepended to the beginning;
#   e.g. 101 is a palindrome, but 1010 is not, however 01010,
#     which represents the same value, is palindromic
#   All palindromes are also pseudopalindromes since the prepending
#     of no zeroes at all is also an option
define is_pseudopalindrome(base,x){
 auto os
 if(bijective)return is_palindrome(base,x);
 os=scale;scale=0;base/=1;x/=1
  .=base_check_()
  if(x==0){scale=os;return 1}
  if(x<0)x=-x
  while(x%base==0)x/=base
 scale=os;return reverse(base,x)==x
}

# returns an odd-lengthed palindrome in the given base, specified by x
define make_odd_palindrome(base, x) {
  auto s
  .=base_check_()
  s=1;if(x<0){s=-1;x=-x}
  x+=bijective;.=bmod_(x,base)
  x=x*base^(digits(base,x)-1) + reverse(base,bdiv_)
  return s*x
}

# returns an even-lengthed palindrome in the given base, specified by x
define make_even_palindrome(base, x) {
  auto s
  .=base_check_()
  s=1;if(x<0){s=-1;x=-x}
  x+=bijective;
  x=x*base^digits(base,x) + reverse(base,x)
  return s*x
}

   #base ten thoughts:
   #output will have either 2n-1 or 2n digits
   #x=19; => n=digits((19+1)/2)= digits(10)=2
   #block for n=1 runs from 1   to 1  +9  +9  -1=18
   #block for n=2 runs from 19  to 19 +90 +90 -1=198
   #block for n=3 runs from 199 to 199+900+900-1=1998
   #block for n runs from 2*10^(n-1)-1 to 2*10^n-2
   # where is x within that block?
   #  last entry of first half of block is akin to 19+90-1=108 or 199+900-1=1098
   #  i.e. 10^n-10^(n-1)-2 = 11*10^(n-1)-2
   # so if x < 11*10^(n-1)-1, x is in the first half
   #
   # if x is in first  half, must subtract 9 or 99 etc. = 10^(n-1)-1
   # if x is in second half, must subtract 99 or 999 etc. = 10^n - 1
   # depending on half choose odd or even palindrome based on x

# for each integer x, return a unique palindrome in the given base
#  i.e. map the integers into palindromes
#  n.b. map _is_ strictly increasing
define map_palindrome(base, x) {
  auto os,r,s
  if(bijective){"unimplemented for bijective";return 1/0}
  os=scale;scale=0;x/=1
   s=1;if(x<0){s=-1;x=-x}
   .=base_check_()
   r=base^(digits(base,(x+1)/2)-1)
   if(x<(base+1)*r-1){
     x = make_odd_palindrome(base,x-r+1)
   } else {
     x = make_even_palindrome(base,x-r*base+1)
   }
  scale=os;return s*x
}

# from a palindrome in a given base, generate a unique integer
#  i.e. map the class of palindromes into the integers
define unmap_palindrome(base, x) {
  auto os,r,s
  if(bijective){"unimplemented for bijective";return 1/0}
  os=scale;scale=0
   s=1;if(x<0){s=-1;x=-x}
   .=base_check_()
   r=base^(digits(base,x)/2)
   x=x/r+r-1
  scale=os;return s*x
}

## Stringification

# Determine if a small number is a substring of a larger number in the given base
define is_substring(base,large,small) {
 auto os,m;
 if(bijective){"unimplemented for bijective";return 1/0}
 os=scale;scale=0;base/=1;large/=1;small/=1;
  .=base_check_()
  if(large<0)large=-large
  if(small<0)small=-small
  m=base^digits(base,small)
  while(large){if(large%m==small){m=0;break};large/=base}
 scale=os;return(m==0) 
}

# Catenate (join lexically) two integers in the given base
# e.g. in base ten, the catenation of 1412 and 4321 is 14124321
define int_catenate(base, x,y){
 auto os;
 if(bijective){"unimplemented for bijective";return 1/0}
 os=scale;scale=0;base/=1;x/=1;y/=1
  .=base_check_()
  if(x<0)x=-x
  if(y<0)y=-y
 scale=os;return x*base^digits(base,y)+y
}

# Return the specified number of leftmost digits of a number in the given base
define int_left(base, x, count){
 auto os;
 if(bijective){"unimplemented for bijective";return 1/0}
 os=scale;scale=0;base/=1;x/=1;count/=1
  .=base_check_()
  if(count<0)count=0;
  count=base^count;while(x>=count)x/=base;
 scale=os;return x
}

# Return the specified number of rightmost digits of a number in the given base
define int_right(base, x, count){
 auto os;
 if(bijective){"unimplemented for bijective";return 1/0}
 os=scale;scale=0;base/=1;x/=1;count/=1
  .=base_check_()
  if(count<0)count=0;
  x%=base^count
 scale=os;return x
}

# Return the specified digits of a number in the given base
define int_mid(base, x, start, end){
 auto os,lsz;
 if(bijective){"unimplemented for bijective";return 1/0}
 os=scale;scale=0;base/=1;x/=1;start/=1;end/=1
  .=base_check_()
  if(start<0)start=0;
  if(end<start){scale=os;return 0}
  lsz=base^end;while(x>=lsz)x/=base;
  x%=base^(end-start+1)
 scale=os;return x
}

## Cantor reinterpretation

# Set to zero to suppress warnings from cantor()
cantorwarn_=1

# 0 = don't perform baseto modulus on digit; 1 = modulus
cantormod_=0

# Error checker for below
define cantor_trans_(d) {
  d=d*mul+cons;
  if(scale(d)){
   if(os<5)scale=5 else scale=os;
    d+=A^(2-scale)
   scale=0;d/=1
  }
  if(cantormod_){
    d-=bijective
    d%=baseto;if(d<0)d+=baseto
    d+=bijective
  }
  if(cantorwarn_)if((bijective>d||d>=abt+bijective)&&!warned){
    warned=1;print "cantor warning: made ";
    if(d==0){print "bad zero"
    } else if(bijective>d){print "negative"}else{print "oversized"}
    print " digit for destination base\n";
  }
  return d
}

# Workhorse for managing -ve basefroms
define cantor_trans_negabase_(basefrom, baseto, mul, cons, x) {
  auto os,i,bf2,bt2,d,a[],shft,y,p,abt
  os=scale;scale=0;basefrom/=1;baseto/=1
  if(basefrom>1)base=-base
  if(basefrom>-2)base=-obase
  bf2=basefrom*basefrom
  bt2=baseto*baseto
  abt=baseto;if(abt<0)abt=-abt
  bijective=!!bijective
  i=x/1;shft=0;if(x!=i)shft=1
  if(bijective&&shft){
    shft=0
    if(cantorwarn_){
      print "cantor warning: can't do fractional part in bijective mode\n"
    }
  }
  p=bt2
  if(shft){
    d=A^scale(x)
    shft=-1
    p=1;for(i=1;i<=d;i*=bf2){.=shft++;p*=bt2}
    shft+=shft
    x*=i/bf2
  }
  for(i=1;x;i++){
    d=((x-bijective)%basefrom)+bijective;if(d<bijective)d-=basefrom;a[i]=d/1
    if(shft)if(!--shft)a[++i]=-1
    x=(x-d)/basefrom
  }
  if(shft){
    while(shft--)a[i++]=0
    a[i++]=-1
  }
  y=0
  for(--i;i;i--)if((d=a[i])==-1){
   # skip decimal point
  } else {
   y=y*baseto+cantor_trans_(d)
  }
  scale=os;return (y*bt2)/p
}

# Treat x's representation in basefrom as a representation
# in baseto and return the resulting number, allowing for a translation
# of digits via multiplier and offset constant
# e.g. Cantor's original transformation from binary to ternary
#      can be represented here by cantor_trans(2,3, 2,0, x)
#      i.e. from base 2 to base 3, multiplying by 2, adding nothing (0)
define cantor_trans(basefrom, baseto, mul, cons, x) {
  auto d,y,p,ix,fx,os,warned,abt;
  cantorwarn_=!!cantorwarn_; bijective=!!bijective;
  os=scale;scale=0
  basefrom/=1;baseto/=1
  ix=2-bijective;fx=3-bijective;d=0
  if(-2<basefrom&&basefrom<ix)d=basefrom=ix
  if(-2<baseto&&baseto<ix)d=baseto=fx
  if(d&&cantorwarn_)print "cantor warning: bad base supplied.\n"
  if(basefrom==baseto&&mul==1&&cons==0){scale=os;return x}
  if(basefrom<0){scale=os;return cantor_trans_negabase_(basefrom,baseto,mul,cons,x)}
  abt=baseto;if(abt<0)abt=-abt
  ix=x/1;fx=x-ix
  warned=0
  p=1
  # integer part
  while(ix){
    d=bmod_(ix,basefrom)
    ix=bdiv_
    y+=p*cantor_trans_(d)
    p*=baseto
  }
  if(fx==0){scale=os;return y}
  if(bijective){
    if(cantorwarn_){
      print "cantor warning: can't do fractional part in bijective mode\n"
    }
    scale=os;return y
  }
  # fractional part
  p=1
  scale=os+=os
  while(p){
    fx*=basefrom;
    scale=0;d=fx/1;fx-=d;scale=os
    p/=baseto
    scale=0;y+=p*cantor_trans_(d);scale=os
  }
 scale/=2
 return y/1  
}

# Treat x's representation in basefrom as a representation
# in baseto and return the resulting number
define cantor(basefrom, baseto, x) {
  if(basefrom==baseto)return x;
  return cantor_trans(basefrom, baseto, 1, 0, x)
}

###from http://phodd.net/gnu-bc/code/digits_describe.bc
### Digits-Describe.BC - Numbers that describe numbers
### Look-and-say
### Numbers describing numbers 
# Workhorse for the below
define describe_(opt,base,x) {
  auto os,c,od,d,p,y,er;
  os=scale;scale=0
  x/=1;if(x<0)x=-x
  p=1;y=0;er=0;while(x){
   d=x%base;c=0
   while(x%base==d){.=c++;x/=base}
   if(!er&&c>=base){
     er=1;print "describe_count"
     if(opt){print"last"}else{print"first"}
     print ": count too large; unwanted carry\n"
   }
   if(opt){d=d*base+c}else{d=c*base+d}
   y+=p*d
   p*=base^2
  }
  scale=os;return y
}

# Returns a number which describes the input in the given base
# count first 11233 -> 211223 (two ones, one two, two threes)
define describe_countfirst(base,x) { return describe_(0,base,x) }
# count last 11233 -> 122132 (one twice, two once, three twice)
define describe_countlast(base,x) {  return describe_(1,base,x) }

# Workhorse for the below
define parserle_(opt,base,x) {
  auto os,c,d,p,y,er;
  os=scale;scale=0
  x/=1;if(x<0)x=-x
  p=1;y=0;er=0;while(x){
    if(opt){c=x%base;x/=base}
    d=x%base;x/=base
    if(!opt){c=x%base;x/=base}
    if(!er&&c==0){
      er=1;print "parserle_count"
      if(opt){print"last"}else{print"first"}
      print": invalid input detected\n"
    }
    for(.=.;c;c--){y+=p*d;p*=base}
  }
  scale=os;return y
}

# Inverse of the 'describe' functions; Parse the Run Length Encoding
define parserle_countfirst(base,x) { return parserle_(0,base,x) }
define parserle_countlast(base,x) {  return parserle_(1,base,x) }

### from http://phodd.net/gnu-bc/code/digits_happy.bc
### Digits-Happy.BC - Tracking the chain of numbers which leads to happiness
###  A suite of functions for investigating the so-called Happy Numbers. This library supports the bijective global variable used elsewhere in these files. When this variable is non-zero (and thus bijective mode is enabled), numbers are also considered to be happy if the iteration reaches the base and not just 1. 
max_array_ = 4^8-1
bijective = 0

# Workhorse function - use POSIX scope to check
# . 'base' parameter of many functions here
define base_check_happy_() {
  bijective=(b=!!bijective)
  if(base<2){
    if(base<=-2){
      print "Negative bases not currently supported; "
    } else if(base==-1||base==0||base==1) {
      print "Nonsense base: ",base,"; "
    }
    print "Using ibase instead.\n"
    base=ibase
  }
}

# Definition of a happy number:
#  In a given base, take the digits of a number,
#    square each one and sum them
#  If, in repeating this process, the number 1
#    is reached (or the value of the given base
#    itself in the case of bijective numeration)
#    then the number is considered to be 'happy'

# Generalised happy number determination
#  returns 1 if x is happy in the given base
#   when raising digits to the given power
#  The original happy numbers are determined using
#   base ten and squaring of digits, i.e. is_happy(A,2,x)
define is_happy(base,pow,x) {
  auto os,t,i,tape[],tapetop,b;
  os=scale;scale=0
  base/=1;pow/=1;x/=1
  .=base_check_happy_()
  if(pow <1)pow=2
  if(x<0)x=-x
  if(x==0){scale=os;return 0}
  tapetop=-1
  while(1){
    for(t=0;x;x/=base)t+=((x-b)%base+b)^pow
    if(t==1||t==base^bijective){scale=os;return 1}
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){scale=os;return 0}
    if(tapetop++>max_array_){
      print "is_happy: can't calculate happiness; chain too long\n"
      scale=os;return 0
    }
    tape[tapetop]=x=t
  }
}

# Print the chain of iterations of x until a loop or 1
define happy_print(base,pow,x) {
  auto os,t,i,tape[],tapetop,b;
  os=scale;scale=0
  base/=1;pow/=1;x/=1
  .=base_check_happy_()
  if(pow <1)pow=2
  if(x<0)x=-x
  if(x==0){scale=os;return 0}
  tapetop=-1
  while(1){
    for(t=0;x;x/=base)t+=((x-b)%base+b)^pow
    if(t==1||t==base^bijective){scale=os;return t}
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){scale=os;"looping ";return t}
    if(tapetop++>max_array_){
      print "happy_print: can't calculate happiness; chain too long\n"
      scale=os;return 0
    }
    tape[tapetop]=x=t;t
  }
}

# Return 1 for happy numbers or the smallest number in the loop
# that the iteration becomes trapped within.
define happy_root(base,pow,x) {
  auto os,t,i,tape[],tapetop,b;
  os=scale;scale=0
  base/=1;pow/=1;x/=1
  .=base_check_happy_()
  if(pow <1)pow=2
  if(x<0)x=-x
  if(x==0){scale=os;return 0}
  tapetop=-1
  while(1){
    for(t=0;x;x/=base)t+=((x-b)%base+b)^pow
    if(t==1||t==base^bijective){scale=os;return t}
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){
      #go back the other way looking for the lowest value
      while(++i<=tapetop)if(tape[i]<t)t=tape[i]
      scale=os;return t
    }
    if(tapetop++>max_array_){
      print "happy_root: can't calculate happiness; chain too long\n"
      scale=os;return 0
    }
    tape[tapetop]=x=t
  }
}

# For unhappy numbers, returns the size of the loop the iterations
# become trapped within. e.g. 4 -> 16 -> ... -> 20 -> 4 is a loop of 8
define happy_loopsize(base,pow,x) {
  auto os,t,i,tape[],tapetop,b;
  os=scale;scale=0
  base/=1;pow/=1;x/=1
  .=base_check_happy_()
  if(pow <1)pow=2
  if(x<0)x=-x
  if(x==0){scale=os;return 1}
  tapetop=-1
  while(1){
    for(t=0;x;x/=base)t+=((x-b)%base+b)^pow
    if(t==1||t==base^bijective){scale=os;return 1}
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){ scale=os;return tapetop-i+1 }
    if(tapetop++>max_array_){
      print "happy_loopsize: can't calculate happiness; chain too long\n"
      scale=os;return -1
    }
    tape[tapetop]=x=t
  }
}

# Find how many iterations are required to reach 1 = happiness
define happy_chainlength(base,pow,x) {
  auto os,t,i,c,tape[],tapetop,b;
  os=scale;scale=0
  base/=1;pow/=1;x/=1
  .=base_check_happy_()
  if(pow <1)pow=2
  if(x<0)x=-x
  if(x==0){scale=os;return 0}
  tapetop=-1
  while(1){
    .=c++
    for(t=0;x;x/=base)t+=((x-b)%base+b)^pow
    if(t==1||t==base^bijective){scale=os;return c}
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){ scale=os;return 2-c }# infinity
    if(tapetop++>max_array_){
      print "happy_chainlength: can't calculate happiness; chain too long\n"
      scale=os;return -c
    }
    tape[tapetop]=x=t
  }
}

# All of the above rolled into one. Negative values suggest error condition.
# Global variables are set with the same names as the above functions
# with the exception of global variable happy_print, which should be
# set to non-zero if emulation of the happy_print() function is required
define is_happy_sg(base,pow,x) {
  auto os,t,i,c,tape[],tapetop,b;
  os=scale;scale=0
  base/=1;pow/=1;x/=1
  .=base_check_happy_()
  if(pow <1)pow=2
  if(x<0)x=-x
  if(x==0){
    happy_root        = 0
    happy_loopsize    = 1
    happy_chainlength = 0
    scale=os;return 0
  }
  tapetop=-1
  while(1){
    .=c++
    for(t=0;x;x/=base)t+=((x-b)%base+b)^pow;if(happy_print)t
    if(t==1||t==base^bijective){
      happy_root        = t
      happy_loopsize    = 0
      happy_chainlength = c
      scale=os;return 1
    }
    # Search backwards for previous occurrence of t (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==t){
      happy_loopsize    = tapetop-i+1
      happy_chainlength = 2-c # Infinite
      #go back the other way looking for the lowest value
      while(++i<=tapetop)if(tape[i]<t)t=tape[i]
      happy_root        = t
      scale=os;return 0
    }
    if(tapetop++>max_array_){
      happy_root        = -1 # Error: Unknown
      happy_loopsize    = -1 # Error: Unknown
      happy_chainlength = -c
      print "is_happy_sg: can't calculate happiness; chain too long\n"
      scale=os;return 0 # not happy
    }
    tape[tapetop]=x=t
  }
}

###from http://phodd.net/gnu-bc/code/digits_misc.bc
### Digits-Misc.BC - Treat numbers as strings of digits II
### Some of the more obscure digit stringification functions you may wish to encounter, removed from digits.bc as interesting but unnecessary, or rolled in from various old bc files long removed from this page.
### Counting calculator display segments
### Multiply digits
### Count digits into arrays
### Negapalindromes
### Pan digital halving index 
 ## Functions of interest but questionable worth

# Workhorse function - use POSIX scope to check
# . 'base' parameter of many functions here
define base_check_misc_() {
  if(bijective)print "Bijective mode not supported by this function.\n"
  if(base<2){
    if(base<=-2){
      print "Negative bases not currently supported; "
    } else if(base==-1||base==0||base==1) {
      print "Nonsense base: ",base,"; "
    }
    print "Using ibase instead.\n"
    base=ibase
  }
}
 
# Product of each digit with one added, less 1
# e.g. 235 -> (2+1)(3+1)(5+1)-1 = 3*4*6 - 1 = 71 in base ten
define digit_product1(base,x) { 
 auto os,t;
 if(x<0)return digit_product1(base,-x);
 os=scale;scale=0;base/=1;x/=1
  .=base_check_misc_()
  t=1;while(x){t*=1+(x%base);x/=base}
 scale=os;return(t-1)
}

# Product of each digit's corresponding odd numbers through the relation
# digit -> 2*digit + 1, then the result is passed through the inverse relation x -> (x-1)/2
# e.g. 13462 -> ( (2*1+1)(2*3+1)(2*4+1)(2*6+1)(2*2+1)-1 )/2 = (3*7*9*13*5 - 1)/2 = 6142
define digit_product2(base,x) { 
 auto os,t;
 if(x<0)return digit_product2(base,-x);
 os=scale;scale=0;base/=1;x/=1
  .=base_check_misc_()
  t=1;while(x){t*=1+2*(x%base);x/=base}
  t=(t-1)/2
 scale=os;return(t)
}

## Swap digit pairs
define sdp(base,x) {
  auto os,b2,t,nx,dd,dl,dr,pw;
  if(x<0)return sdp(base,-x)
  .=base_check_misc_()
  os=scale;scale=0;base/=1
   b2=base*base
   nx=x/1
   if(scale(x)&&x!=nx){
     pw=A^os;for(t=1;t<=pw;t*=b2){}
     nx=(x*t)/1
     scale=os;return sdp(base,nx)/t
   }
   x=nx;pw=1
   for(t=0;x;x=nx){dd=x-(nx=x/b2)*b2;dr=dd-(dl=dd/base)*base;t+=pw*(dr*base+dl);pw*=b2;x=nx}
  scale=os;return t
}

## Palindromes

# Determine if x is a negapalindrome (type 1) in the given base
# - an NP is any number whose opposing pairs of digits,
#   (counted in from either end) sum to one less than the base
# e.g. 147258 is an NP(1) in base ten since 1+8 = 4+5 = 7+2 = 9 = ten - 1
define is_negapalindrome(base,x) {
  auto os
  os=scale;scale=0;base/=1;x/=1
   .=base_check_misc_()
   # divisibility by base-1 is a necessary condition for [P]NP(1)s in even bases
   # divisibility by (base-1)/2 is a necessary condition for [P]NP(1)s in odd bases
   if(x%((base-1)/(1+base%2))!=0){scale=os;return 0}
   if(x<0)x=-x
   x += reverse(base,x)+1
   if(x<base){scale=os;return 0}
   while(x%base==0)x/=base
  scale=os;return(x==1)
}

# workhorse function for is_pseudonegapalindrome
define stripbm1s_(base,x) {
 auto d;d=base-1;
 while(x%base==d){x/=base}
 return x
}

# Determine if x is a pseudonegapalindrome (type 1) in the given base
# - a PNP is a number that could be a negapalindrome
#   if a number of zeroes is prepended to the beginning;
# e.g. 1899 is a PNP in base ten since it can be written 001899
#   All NPs are also PNPs since the prepending
#     of no zeroes at all is also an option
define is_pseudonegapalindrome(base,x) {
 auto os
 os=scale;scale=0;base/=1;x/=1
  .=base_check_misc_()
  # divisibility by base-1 is a necessary condition for [P]NP(1)s
  if(x==0||x%(base-1)!=0){scale=os;return 0}
  if(x<0)x=-x
  x = stripbm1s_(base,x)
  x += reverse(base,x)
  x = stripbm1s_(base,x)
 scale=os;return (x==0)
}

# Determine if x is a negapalindrome (type 2) in the given base
# - an NP is any number whose opposing pairs of digits,
#   (counted in from either end) sum to one less than the base
# e.g. 9415961 is an NP(2) in base ten since 9+1 = 4+6 = 1+9 = 5+5 = ten
#   note that the 5 counts double and pairs with itself
define is_negapalindrome2(base,x) {
  auto os
  os=scale;scale=0;base/=1;x/=1
   .=base_check_misc_()
   if(x<0)x=-x
   x += reverse(base,x)+1
   if(x<base){scale=os;return 0}
   while(x%base==1)x/=base
  scale=os;return (x==0)
}

# There is no such thing as a PNP (type 2) as this would require a digit
# to pair with zero that is equal to the value of the base.

define map_negapalindrome(base, x){
  auto os,r,s
  os=scale;scale=0;x/=1
   s=1;if(x<0)x*=(s=-1)
   .=base_check_misc_()
   if(base%2){
     if(x==0){x=base/2;scale=os;return x}
     r=base^(digits(base,(x+1)/2)-1)
     if(x<(base+1)*r-1){
       #make negapalindrome
       x-=r-1
       r*=base
       x=x*r+reverse(base,r-1-x)
     } else {
       #make negapalindrome with central digit
       r*=base
       x-=r-1
       x=(x*base+base/2)*r+reverse(base,r-1-x)
     }
   } else {
     .=x++ # without this x=0 -> a single digit NP(1), which is invalid for even bases
     r=base^digits(base,x)
     x=x*r+reverse(base,r*base-1-x)/base
   }
  scale=os;return s*x
}

define unmap_negapalindrome(base, x) {
  auto os,r,s
  os=scale;scale=0
   s=1;if(x<0)x*=(s=-1)
   .=base_check_misc_()
   if(base%2){
     r=base^((digits(base,x)+1)/2)
     x=x/r+r/base-1
   } else {
     r=base^(digits(base,x)/2)
     x=x/r-1
   }
  scale=os;return s*x
}

  ## To do (one day): map_ functions for remaining NPs and PNPs
  
## Calculator segments

# Return the number of segments of a 7-segment calculator display that
#   are required to display the value of x in the given base.
# Supports up to base 36; Some calculators may have a different number
#   of segments per number than given here.
define calcsegments(base,x) {
  auto os,oib,s[],t;
  oib=ibase;ibase=A
   s[ 0]=s[ 6]=s[ 9]=s[10]=s[32]=6
   s[ 1]=s[27]=2
   s[ 2]=s[ 3]=s[ 5]=s[11]=s[13]=s[14]=s[16]=s[25]=s[26]=s[31]=s[34]=5
   s[ 4]=s[12]=s[15]=s[17]=s[20]=s[24]=s[28]=s[29]=s[35]=4
   s[ 7]=s[19]=s[21]=s[22]=s[23]=s[30]=s[33]=3
   s[ 8]=7
   s[18]=1
  ibase=oib
  os=scale;scale=0;x/=1
  t=0;if(x<0){t=1;x=-x}
  if(x==0){scale=os;return s[0]}
  if(2>base||base>6*6){
    print "calcsegments: only bases 2 to 36 (decimal) supported\n";
    base=A
  }
  while(x){t+=s[x%base];x/=base}
  scale=os;return t
}

## Miscellaneous

# The base number created by appending all base numbers
# from 1 to x, e.g. in base ten: 1, 12, 123, ..., 123456789101112, etc.
define append_all(base,x) {
 auto a,i,m,l,os;
 os=scale;scale=0;base/=1;x/=1
  .=base_check_misc_()
  if(x<=0)return(0);
  m=1;while(x){l=m;m*=base;for(i=l;i<m&&x;i++){a=a*m+i;.=x--}}
 scale=os;return(a)
}

# returns a number with the digits sorted into descending order
define sort_digits_desc(base,x) {
 auto os,i,d[];
 if(x<0)return sort_digits_desc(base,-x)
 os=scale;scale=0
 base/=1;x/=1
 .=base_check_misc_()
 for(i=0;i<base;i++)d[i]=0
 while(x>0){.=d[x%base]++;x/=base}
 for(i=base-1;i>=0;i--)if(d[i])for(j=0;j<d[i];j++)x=base*x+i
 scale=os
 return x
}

# returns a number with the digits sorted into ascending order
define sort_digits_asc(base,x) {
 auto os,i,d[];
 if(x<0)return sort_digits_asc(base,-x)
 os=scale;scale=0
 base/=1;x/=1
 .=base_check_misc_()
 for(i=0;i<base;i++)d[i]=0
 while(x>0){.=d[x%base]++;x/=base}
 for(i=1;i<base;i++)if(d[i])for(j=0;j<d[i];j++)x=base*x+i
 scale=os
 return x
}

## Digit counting / splitting with arrays

# Count the occurrences of a particular digit in a number in the given base
# . caution - only works on integers
define count_digit(base,x,digit) {
  auto os,count;
  if(x<0)x=-x
  os=scale;scale=0
  base/=1;x/=1
  .=base_check_misc_()
  for(count=0;x;x/=base)if(x%base==digit).=count++
  scale=os;return count
}

# Combination of count_digit(), digits() and an array[]
# . sets an array to contain the counts of all digits in the given base
# . array is terminated by -1
# . e.g. count_digits(a[],A,110247544) = 9 and a[] = {1,2,1,0,3,1,0,1,0,0,-1}
# . caution - only works on integers
define count_digits(*d__[],base,x) {
  auto os,count;
  if(x<0)x=-x
  os=scale;scale=0
  base/=1;x/=1
  .=base_check_misc_()
  for(count=0;count<base;count++)d__[count]=0;
  for(count=0;x;x/=base){.=count++;.=d__[x%base]++}
  d__[base]=-1
  scale=os;return count;
}

# Split the digits of x into the given array
# . handles floating point numbers
# . basimal point is always present, and is represented by an array element
#   whose absolute value is the base (since this is too large to be a digit)
# . the sign of the basimal point value carries the sign of x
#   (hence always needing to be present)
# . array is terminated with -1 (an invalid base for a basimal point)
# . e.g. split_digits(a[],10,-15.725) sets a[] to {1,5,-10,7,2,5,-1}
#        split_digits(a[],10,3) sets a[] to {3,10,-1}
define split_digits(*d__[],base,x) {
  auto os,s,b,i,ix,fx,p;
  if(x==0){d__[0]=0;d__[1]=-1;return 0}
  s=1;if(x<0){s=-1;x=-x}
  os=scale;scale=0
  base/=1
  .=base_check_misc_()
  fx=x-(ix=x/1)
  while(ix%base==0){b++;ix/=base}
  ix=reverse(base,ix);i=0
  while(ix){d__[i++]=ix%base;ix/=base}
  while(b--)d__[i++]=0
  d__[i++]=s*base
  for(p=1;fx&&p<A^os;p*=base){fx*=base;fx-=(d__[i++]=fx/1)}
  d__[i++]=-1;scale=os;return 0
}

# Puts an array generated by split_digits() back together
# . since all relevant information is encoded in the array, only the
#   array parameter is required. will complain on finding a problem
# . To convert numbers digitwise to another base, instead see the
#   cantor*() functions
define join_digits(d__[]) {
  auto os,i,m,n,base,d,s,x,p;
  os=scale;scale=0
  m=n=d__[0];for(i=1;(d=d__[i])!=-1;i++)if(m<d){m=d}else if(n>d){n=d}
  s=1;if(-n>=m){s=-1;base=-n}else{base=m}
  for(i=0;(d=d__[i])<base&&d>=0;i++)x=x*base+d
  if(d__[i]!=s*base){print "join_digits: unexpected element in array\n";scale=os;return x/s}
  scale=os+5;x+=5*A^(-1-os)
  for(p=1/base;p&&(d=d__[++i])<base&&d>=0;p/=base)x+=d*p
  if(d__[i]!=-1)print "join_digits: unexpected element in array\n";
  scale=os;return x/s
}

## Pandigital Index

# pdhi(x) - Pan Digital Halving Index
# Returns how many times x must be divided by 2 before
# the result contains all digits from 0 to 9 (if ibase = 10).
# e.g. 3339 -> 1669.5 -> 834.75 -> 417.375 ->
#      208.6875 -> 104.34375 -> 52.171875 ->
#      26.0859375 -> 13.04296875, i.e. 8 times

# Uses ibase as the base for divisions (usually 10)

define pdhi(x) {
  auto d[],xi,xf,c,r,pdhi,lim,i;
  if(x==0){print "pdhi: Infinity\n";return A^scale-1}
  if(x<0)x=-x
  c=1;pdhi=-1;lim=int(A/ibase+3)*scale
  while(c){
    pdhi+=1
    xi=int(x);xf=x-xi
    while(xi){
      r=int(xi/ibase)
      d[xi-ibase*r]=1
      xi=r
    }
    for(i=lim ; i && xf ; i--){
    #while(xf){
      xf*=ibase
      r=int(xf)
      d[r]=1
      xf-=r
    }
    c=ibase
    for(r=0;r<ibase;r++){c-=d[r];d[r]=0}
    x/=2
  }
  return pdhi;
}

# pdmi(x, m) - Pan Digital Multiplying Index
# Returns how many times x must be multiplied by m before
# the result contains all digits from 0 to 9 (if ibase = 10).
# e.g. pdmi(3339,0.5) -> 1669.5 -> 834.75 -> 417.375 ->
#      208.6875 -> 104.34375 -> 52.171875 ->
#      26.0859375 -> 13.04296875, i.e. 8 times

# Uses ibase as the base for divisions (usually 10)

define pdmi(x,m) {
  auto d[],xi,xf,c,r,pdmi,lim,i;
  if(x==0){print "pdmi: Infinity\n";return A^scale-1}
  if(x<0)x=-x
  c=1;pdmi=-1;lim=int(A/ibase+3)*scale
  while(c){
    pdmi+=1
    xi=int(x);xf=x-xi
    while(xi){
      r=int(xi/ibase)
      d[xi-ibase*r]=1
      xi=r
    }
    for(i=lim ; i && xf ; i--){
    #while(xf){
      xf*=ibase
      r=int(xf)
      d[r]=1
      xf-=r
    }
    c=ibase
    for(r=0;r<ibase;r++){c-=d[r];d[r]=0}
    x*=m
  }
  return pdmi;
}

###from http://phodd.net/gnu-bc/code/factorial.bc
### Factorial.BC - Approximations to, and methods for calculating factorials
### A suite of functions for calculations involving the factorial and its relatives. Migrated from funcs.bc and then expanded upon. Still requires funcs.bc to work correctly.
###     Factorial
###     Combination (Binomial Coefficients)
###     Permutation
###     Derangements
###     LCM factorial / LCMultorial
###     Euler gamma constant 
 # Requires funcs.bc
# Gosper's approximation to the natural log of x!
define gosper(x) {
 auto os,s,intx,pi;
 pi=pi();
 if(x==0)return 0 
 if(x<0){
   os=scale;scale=0;intx=x/1;scale=os
   if(x==intx) return (-1)^x*A^scale
   x=-x;pi*=x
   s=s(pix)
   if(s<=0) return 1-A^scale
   return l(pix/s)-gosper(x)
 }
 return(  x*(l(x)-1) + ( l(2*x+1/3)+ l(pi) )/2  )
}

# Gosper's approximation to n!
define gfactorial(n) { return ceil(e(gosper(n))) }

# Nemes' approximation to the natural log of x!
# with minor tweak to bring it closer to the true value
define nemes(x) {
 auto os,s,lx,intx,pix,l10,corr;
 pix=pi()*x;
 if(x==0||x==1)return 0 
 if(x<0){
   os=scale;scale=0;intx=x/1;scale=os
   if(x==intx) return (-1)^x*A^scale
   x=-x;pix=-pix
   s=s(pix)
   if(s<=0) return 1-A^scale
   return l(pix/s)-nemes(x)
 }
 lx = l(x)
 s = x*(lx-1) + l(2*pix)/2 + 1/(C*x + 2/(5*x + (5*A+3)/(4*A+2)/x))
 l10 = ((A*5*7-3)*E*B+5)/(A*B*(E*F+1)) # approximation to log 10
 corr = 7*(9/8+lx)
 if(corr/l10 < scale){
   #"correcting ";s
   s -= e(-corr) # minor correction
 }
 return s;
}

# Nemes' approximation to n!
define nemfactorial(n) {
  auto a;
  a=n=nemes(n);if(a<0)a=-a
  if(a+a>A^scale)return n
  return e(n)
}

# Stieltjes approximation to ln(n!)
define stieltjes(n) {
  auto oib,os,ln,intn,pin,a[],s,i
  if(n==0||n==1)return 0 
  if(n<0){
    os=scale;scale=0;intn=n/1;scale=os
    if(n==intn) return (-1)^n*A^scale
    n=-n;pin=pi()*n;s=s(pin)
    if(s<=0) return 1-A^scale
    return l(pin/s)-stieltjes(n)
  }
  oib=ibase;ibase=A;scale+=50
  a[B]=100043420063777451042472529806266909090824649341814868347109676190691/13346384670164266280033479022693768890138348905413621178450736182873
  a[A]=152537496709054809881638897472985990866753853122697839/24274291553105128438297398108902195365373879212227726
  a[9]=26370812569397719001931992945645578779849/5271244267917980801966553649147604697542
  a[8]=455377030420113432210116914702/113084128923675014537885725485;a[7]=29404527905795295658/9769214287853155785;a[6]=109535241009/48264275462
  a[5]=29944523/19773142;a[4]=22999/22737;a[3]=195/371;a[2]=53/210;a[1]=1/30;a[0]=1/12
  s=1;for(i=B;i>=0;i--)s=n+a[i]/s;s-=n
  s+=l(2*pi())/2-n+(n+.5)*l(n)
  obase=oib;scale-=50;return s/1
}

# Stieltjes' approximation to n!
define stielfactorial(n) {
  auto a;
  a=n=stieltjes(n);if(a<0)a=-a
  if(a+a>A^scale)return n
  return e(n)
}

# Spouge factorial - workhorse for below
define spouge_(n,l,exact){
  auto os,h,tltp,tp,a,k,f,e1,z,iz,fz,d,nm,dm;
  os=scale;scale=1;h=1/2;scale=os+os
  if(exact&&os>3){scale=3;a=spouge_(n,0,0);scale=8*length(a)/5+os}
  tltp=2*l(tp=2*pi());a=lambertw0(A^scale*tltp/tp)/tltp
  nm=sqrt(tp);dm=1;e1=e(1)
  f=1;for(k=1;k<a;k++){
    #z=-e((k-h)*l(a-k)+a-k)*(-1)^k
    z=(k-h)*l(a-k)+a-k
    #z=-pow(e1,z)*(-1)^k
    scale=0
     iz=z/1;fz=z-iz
     z=fastintpow__(e1,iz)
    scale=os+os
    if(fz>h){z*=e1/e(1-fz)}else{z*=e(fz)}
    z=-z*(-1)^k
    d=f*(n+k)
    nm=nm*d+dm*z
    dm*=d
    f*=k
  }
  z=(n+h)*l(n+a)-n-a
  if(l){
    z+=l(nm/dm)
  } else {
    #z=pow(e1,z)*nm/dm
    z=e(z)*nm/dm
  }
  scale=os
  return z/1
}

# ... calculate to scale decimal places - slow!
define spougefactorialx(n) { return spouge_(n,0,1) }
define spougex(n)          { return spouge_(n,1,1) }

# ... calculate to scale significant figures
define spougefactorial(n)  { return spouge_(n,0,0) }
define spouge(n)           { return spouge_(n,1,0) }

# generate the Euler's gamma constant to the current scale
# . Warning - Slow to calculate
# . Caches calculated value to save on recalculation for
# . . same or smaller scales
define eulergamma() {
  # Uses fact that eulergamma = -Gamma'(1)
  auto os,eps,g;
  if(scale==(os=scale(eulergamma_)))return eulergamma_
  if(scale<os)return eulergamma_/1
  os=scale;if(scale<5)scale=5
  scale=ceil(scale*(A*A+6)/(6*A+7)) # scale/(1-1/e)
  eps=A^-scale
  scale+=scale
  g=(spouge_(-eps,0,0)-spouge_(eps,0,0))/(eps+eps)
  scale=os;return eulergamma_=g/1
}

# x! - an approximation to the factorial function over the reals
#      is accurate as possible for all integers and half-integers
#      interpolates otherwise
factorial_substrate_=2
define factorial_substrate_(n) {
  if(factorial_substrate_==0)return pow(e(1),gosper(n))
  if(factorial_substrate_==1)return pow(e(1),nemes(n))
  if(factorial_substrate_==2)return pow(e(1),stieltjes(n))
  if(factorial_substrate_==3)return spougefactorial(n)
  if(factorial_substrate_==4)return spougefactorialx(n)
  factorial_substrate_=2
  return factorial_substrate_(n);
}
define factorial(x) {
 auto i,xx,x2,xx2,k,a,b,na,nb,os,oib
 if(x==0||x==1)return 1
 oib=ibase;ibase=A
 if(x==0.5){ibase=oib;return sqrt(pi()/4)}
 if(0<x&&x<1){
  .=x++;ibase=oib
  return factorial(x)/x
 }
 os=scale;scale=0;xx=x/1;scale=os
 if(x<0){
   if(x==xx) return (-1)^xx*A^scale
   x=-x;
   a=pi()*x;
   ibase=oib
   return a/s(a)/factorial(x)
 }
 x2=x+x
 os=scale;scale=0;xx2=x2/1;scale=os
 if(x==xx){
  xx=1;for(i=x;i>=1;i--)xx*=i
  ibase=oib
  return xx;
 } else if (x2==xx2) {
  x-=.5
  xx=1;for(i=x2;i>x;i--)xx*=i
  scale+=x;
   xx/=2^(xx2-1)
   xx*=sqrt(pi()/4)
  scale-=x;
  ibase=oib
  return xx/1;
 }
 /* Other factorial cases here */
 if(factorial_substrate_>=3){ibase=oib;return spouge_(x,0,factorial_substrate_-3)}
  x2=2*(x-xx)
  if(x2>.5){
   x2-=.5
   xx+=.5
  }
  xx+=5
   a=factorial(            xx    )
  na=factorial_substrate_( xx    )
   b=factorial(            xx+0.5)
  nb=factorial_substrate_( xx+0.5)
  k=na/a
  k+=(nb/b-k)*x2
  xx=factorial_substrate_(x+5)/(k*(x+5)*(x+4)*(x+3)*(x+2)*(x+1))
 ibase=oib
 return xx;
}

define lnfactorial_substrate_(n) {
  if(factorial_substrate_==0)return    gosper(n)
  if(factorial_substrate_==1)return     nemes(n)
  if(factorial_substrate_==2)return stieltjes(n)
  if(factorial_substrate_==3)return    spouge(n)
  if(factorial_substrate_==4)return   spougex(n)
  factorial_substrate_=2
  return lnfactorial_substrate_(n);
}
# logarithm of the above
define lnfactorial(x) {
 auto i,xx,x2,xx2,k,a,b,na,nb,os,oib;
 if(x==0||x==1)return 0
 oib=ibase;ibase=A
 if(x==0.5){ibase=oib;return l(pi()/4)/2}
 if(x<=2470){ibase=oib;return ln(factorial(x))} # l(factorial()) is faster below 2470ish
 if(x>1000000){ibase=oib;return stieltjes(x)}
 if(x>10000){ibase=oib;return spouge(x)}
 if(0<x&&x<1){
  .=x++
  return lnfactorial(x)-l(x)
 }
 os=scale;scale=0;xx=x/1;scale=os
 if(x<0){
   x=-x;
   a=pi()*x;
   ibase=oib
   na = s(a)
   if(na<=0) return 1-A^scale
   return l(a/na)-lnfactorial(x)
 }
 x2=x+x
 os=scale;scale=0;xx2=x2/1;scale=os
 if(x==xx){
  xx=0.5*x*A^-scale;for(i=x;i>=1;i--)xx+=l(i)
  ibase=oib
  return xx;
 } else if (x2==xx2) {
  x-=.5
  xx=0.5*x*A^-scale;for(i=x2;i>x;i--)xx+=l(i)
  scale+=scale;
   xx-=(xx2-1)*l(2)
   xx+=0.5*l(pi()/4)
  scale=os;
  ibase=oib
  return xx/1;
 }
 /* Other factorial cases here */
 if(factorial_substrate_>=3){ibase=oib;return spouge_(x,1,factorial_substrate_-3)}
  x2=2*(x-xx)
  if(x2>.5){
   x2-=.5
   xx+=.5
  }
  xx+=5
   a=lnfactorial(            xx    )
  na=lnfactorial_substrate_( xx    )
   b=lnfactorial(            xx+0.5)
  nb=lnfactorial_substrate_( xx+0.5)
  k=na/a
  k+=(nb/b-k)*x2
  #k=(11*k-3)/8 # correction
  xx=(lnfactorial_substrate_(x+5)-l((x+5)*(x+4)*(x+3)*(x+2)*(x+1)))/k
 ibase=oib
 return xx;
}

# Inverse factorial (approximate)
#   Based on a derivation by David W. Cantrell in sci.math
define fast_inverse_factorial(x) {
  auto t,f,eps,os,oib;
  if(x==1||x==2) return x;
  oib=ibase;ibase=A;
  if(0.89<=x&&x<=3.9){
    os=scale
    if(scale>25)scale=25
    eps = A^(5-scale);if(eps>1)eps=1
    t=x;f=x-factorial(t)
    while(abs(f)>eps){t+=f/x;f=x-factorial(t)}
    scale=os;ibase=oib
    return t
  }
  scale += 3
  t = l((x+0.036534)/sqrt(2*pi()))
  t /= lambertw0(t/e(1))
  t -= .5
  scale -= 3
  ibase=oib
  return t/1 
}

# Inverse factorial (as accurate as possible*)
#   *Uses current factorial substrate and the above
#     to iterate to a possible answer
#   Much slower than the above
define inverse_factorial(f) {
  auto os,g0,g1,g2,g3,d,eps
  eps=A^-scale;scale+=5
  os=scale
  g0=fast_inverse_factorial(f)
  if(g0==f||f<1)return g0;
  while(abs(g0-g1)>eps){
    g1=g0
    g2=g1+(f/factorial_substrate_(g1)-1)/l(g1)
    if(g2==g1)break
    g3=g2+(f/factorial_substrate_(g2)-1)/l(g2)
    if(g3==g2){g0=g2;break}
    scale+=scale
     g0=g2
     d=g2+g2-g1-g3
     if(d!=0)g0=(g2*g2-g1*g3)/d #glai
    scale=os
    g0/=1
  }
  scale-=5
  return g0/1
}

# Inverse of lnfactorial (approximate)
define fast_inverse_lnfactorial(x) {
  auto k,f
  if(x<=3)return fast_inverse_factorial(e(x));
  if(x<=6){k=(6-x)/3;f=fast_inverse_factorial(e(x))}
  x-=l(2*pi())/2
  x/=lambertw0(x/e(1))
  x-=1/2
  if(k)x+=k*(f-x)
  return x
}

# Inverse of lnfactorial (as accurate as possible*)
#   *Uses current lnfactorial substrate and the above
#     to iterate to a possible answer
#   Much slower than the above
define inverse_lnfactorial(x) {
  auto g0,g1,g2,n,eps
  eps=A^-scale;scale+=5
  n=x
  g0=fast_inverse_lnfactorial(n)
  if(g0<3){
    scale-=5
    return inverse_factorial(e(x))
  }
  while(abs(g0-g1)>eps) {
    g1=fast_inverse_lnfactorial(n+=x-lnfactorial_substrate_(g0))
    g2=fast_inverse_lnfactorial(n+=x-lnfactorial_substrate_(g1))
    g0=g2
  }
  scale-=5
  return g0/1
}

# Number of permutations of r items from a group of n
# ... using integers only
define int_permutation(n,r) {
 auto i,p,os;
 os=scale;scale=0;n/=1;r/=1
 if(n<0||r<0||r>n)return(0)
 p=1;for(i=n;i>n-r;i--)p*=i
 scale=os;return(p)
}

# ... using real numbers
define permutation(n,r) {
 auto os;os=scale;scale=0
 if(n==n/1&&r==r/1&&n>=0&&r>=0){scale=os;return int_permutation(n,r)}
 if(n<0||r<0){scale=os;return factorial(n)/factorial(n-r)}
 scale=os
 n=lnfactorial(n)-lnfactorial(n-r)
 if(n<=5*A^3)return e(n)
 if(n>=  A^7)print "permutation: calculating huge result; consider using lnpermutation\n"
 return pow(e(1),n)
}

# ... logarithm of the above; good for larger n and r
define lnpermutation(n,r) {
  return lnfactorial(n)-lnfactorial(n-r)
}

# Number of combinations of r items from a group of n
# ... using integers only
define int_combination(n,r) {
 auto c,os;
 os=scale;scale=0;n/=1;r/=1
 if(n<0||r<0||r>n){scale=os;return(0)}
 if(r+r>n)r=n-r
 c=int_permutation(n,r)/factorial(r)
 scale=os;return(c) 
}

# ... using real numbers
define combination(n,r) {
 auto os;os=scale;scale=0
 if(n==n/1&&r==r/1&&n>=0&&r>=0){scale=os;return int_combination(n,r)}
 if(n<0||r<0){scale=os;return factorial(n)/factorial(n-r)/factorial(r)}
 scale=os
 n=lnfactorial(n)-lnfactorial(n-r)-lnfactorial(r)
 if(n<=5*A^3)return e(n)
 if(n>=  A^7)print "combination: calculating huge result; consider using lncombination\n"
 return pow(e(1),n)
}

# ... logarithm of the above; good for larger n and r
define lncombination(n,r) {
  return lnfactorial(n)-lnfactorial(n-r)-lnfactorial(r)
}

# Catalan numbers
define catalan(n) {
  auto os,t;
  if(n==-1)return -1/2;
  t=n+n;os=scale;scale=0
  if(n<0)if(t/1==t){
    t%=2;scale=os
    if(t)return -1+A^os # -ve half-integers -> infinite
    return 0            # -ve integers < -1 -> 0
  }
  scale=os;n=combination(t,n)/(n+1)
  scale=0 ;t=n/1;if(n==t)n=t
  scale=os;return n
}

# double factorial is also written x!! [not equal to (x!)!]
define double_factorial(x) {
 auto i,xx;
 if(x==0||x==1)return 1
 xx=int((x+1)/2)
 if(x<0&&x==xx+xx-1){
   return (-1)^xx*double_factorial(-2*xx-1)
 }
 xx=int(x)
 if(x==xx){
  xx=1;for(i=x;i>=1;i-=2)xx*=i
  return(xx)
 }
 x/=2
 xx=factorial(x)
 x-=.5
 xx*=e(x*l(2))
 xx/=sqrt(pi()/4)
 return xx
}

# number of derangements of n
# . = number of permutations where no element is in its original place
# Is accurate for integers and performs a naive interpolation otherwise
define subfactorial(n){
  auto os,ns,in,fn,a,b,e,sa,sb;
  if(n<0)return 1-A^scale
  if(0<n&&n<1)return (subfactorial(n+1)+c(pi()*n))/(n+1)
  os=scale;scale=0 
  fn=n-(in=n/1)
  if(n==in){
    b=0;for(a=0;a<=n;a++)b=b*a+(-1)^a
    scale=os;return b
  }
  ns=length(factorial(in))-1;if(ns<os)ns=os
  scale=ns
    e=e(1);sb=1/2
    a=factorial(in)/e;b=a*(in+1);n=factorial(n)/e
  scale=0 ;sa=(a+sb)/1;sb=(b+sb)/1
  scale=ns;sa/=a;sb/=b
  scale=os;return n*(sa+fn*(sb-sa))/1
}

# Returns the lowest common multiple of all numbers 1..x
define lcmultorial(x) {
  auto f;
  x=int(x);if(x<=1)return 1
  for(f=1;x>1;x--)f=int_lcm(x,f)
  return f;
}

# y-th factorial of x: x!_y
# ... integers only
define int_multifactorial(y,x) {
 auto i,xx,os;
 os=scale;scale=0;x/=1;y/=1
 xx=1;for(i=x;i>=1;i-=y)xx*=i
 scale=os;return(xx);
}

# only works for x==1 mod y # to fix
#define multifactorial(y,x) {
# auto os,c[],nc[],t,ix,iy
# os=scale;scale=0
# ix=x/1;iy=y/1
# c[00]=int_multifactorial(iy  ,ix)
# if(y==iy&&x==ix&&y>=0&&x>=0){scale=os;return c[00]}
# c[01]=c[00]*(iy  +ix)
# c[10]=int_multifactorial(iy+1,ix)
# c[11]=c[10]*(iy+1+ix)
# scale=os;
# t=lnfactorial(1/iy)
#  nc[00]=e((ix-1)*l(iy)/iy+lnfactorial( ix   /iy)-t)
#  nc[01]=e( ix   *l(iy)/iy+lnfactorial((ix+1)/iy)-t)
# .=iy++
# t=lnfactorial(1/iy)
#  nc[10]=e((ix-1)*l(iy)/iy+lnfactorial( ix   /iy)-t)
#  nc[11]=e( ix   *l(iy)/iy+lnfactorial((ix+1)/iy)-t)
# .=iy--
# for(t=0;t<=11;t++)if(c[t])nc[t]/=c[t]
# c[0]=nc[00]+(nc[01]-nc[00])*(y-iy)
# c[1]=nc[10]+(nc[11]-nc[10])*(y-iy)
# c[0]= c[ 0]+( c[ 1]- c[ 0])*(x-ix)
# return c[0]*e((x-1)*l(y)/y+lnfactorial(x/y)-lnfactorial(1/y))
#}



#from http://phodd.net/gnu-bc/code/factorial_gamma.bc
### Factorial_Gamma.BC - Gamma related functions
 # Requires funcs.bc and factorial.bc
### Near-aliases for some functions in factorial.bc, giving the functions more classical function names.
###    Gamma function
###    Beta function 
# These are all but aliases for functions in factorial.bc

define           gamma(x) { return           factorial(x -1) }
define         lngamma(x) { return         lnfactorial(x -1) }
define   inverse_gamma(x) { return   inverse_factorial(x)+1  }
define inverse_lngamma(x) { return inverse_lnfactorial(x)+1  }

# Derivatives of the above

define   beta(x,y) { return   factorial(x-1)*  factorial(y-1)/  factorial(x+y-1) }
define lnbeta(x,y) { return lnfactorial(x-1)+lnfactorial(y-1)-lnfactorial(x+y-1) }

# For the lowercase Euler gamma constant, see eulergamma() in factorial.bc


###from http://phodd.net/gnu-bc/code/fibonacci.bc
### Fibonacci.BC - Fibonacci and Lucas functions
### Fibonacci and Lucas functions; Originally part of funcs.bc Still requires funcs.bc to work correctly. 
 # Requires funcs.bc

# n-th Fibonacci number over the reals
define fibonacci(n){
  auto a,b,c,intn,count,fracn,s5,os
  if(n==0)return 0
  os=scale;scale=0;count=intn=n/1
  if(n<0){
    scale=os;
    a=-fibonacci(-n)
    if(n==intn)return a*(-1)^(-intn)
    return a*c(pi()*n)
  }
  count+=2;
  a=-1;b=1;c=0
  while(--count){
    c=a+b;a=b;b=c
  }
  scale=os;
  if(n==intn)return c
  
  fracn=n-intn
  s5=sqrt(5)
  a=e(fracn*l( (1+s5)/2 ))
  a*=(s5*c+sqrt(5*c*c+4*(-1)^intn))/2
  a=(a-c(pi()*n)/a)/s5
  return a
}

# inverse of the above - cannot deal with values below 1 (except 0)
# but is accurate to within 'scale' decimal places otherwise
define inverse_fibonacci(f) {
  auto a,b,c,intn,intf,fracf,s5,phinx2,eps,s5f,z5f2,lph,pi,os
  if(f==0)return f
  if(f<1)return 0 # avoid multivalued mess
  os=scale;scale=0;intf=f/1
  a=-1;b=1;c=0
  for(intn=-2;c<=intf;intn++){
    c=a+b;a=b;b=c
  }
  scale=os
  if(f==a)return intn
  c=a
  s5=sqrt(5)
  phinx2=s5*c+sqrt(5*c*c+4*(-1)^intn)
  lph=l( (1+s5)/2 )
  pi=pi()
  s5f=s5*f
  z5f2=5*f*f
  a=0.5 #start guess
  os+=8
  for(scale=8;scale<=os;scale+=8){
    b=0
    eps=A^(2-scale)
    while(abs(a-b)>eps){
      b=a
      a=s5f+sqrt(z5f2+4*c(pi*(intn+a)))
      a/=phinx2
      a=l(a)/lph
    }
    a=(a+b)/2
  }
  os-=8;scale=os;a/=1
  return intn+a
}

# n-th Lucas number over the reals
define lucas(n){
  auto a,b,c,intn,count,fracn,os
  if(n==0)return 2
  os=scale;scale=0;count=intn=n/1
  if(n<0){
    scale=os;
    a=lucas(-n)
    if(n==intn)return a*(-1)^(-intn)
    return a*c(pi()*n)
  }
  count+=2;
  a=3;b=-1;c=2
  while(--count){
    c=a+b;a=b;b=c
  }
  scale=os;
  if(n==intn)return c
  
  fracn=n-intn
  a=e(fracn*l( (1+sqrt(5))/2 ))
  a*=(c+sqrt(c*c-4*(-1)^intn))/2
  a=a+c(pi()*n)/a
  return a
}

# inverse of the above - inaccurate with values below 2 (except -1, 0 and 1)
# but is accurate to within 'scale' decimal places otherwise
define inverse_lucas(l) {
  auto a,b,c,intn,intl,fracl,phinx2,eps,l2,lph,pi,os
  if(l<-1)return -1
  if(-1<=l&&l<1)return ((7-3*l)*l-A)/(2*A)
  if(1<=l&&l<=2)return 2-l # avoid multivalued mess
  os=scale;scale=0;intl=l/1
  a=3;b=-1;c=2
  for(intn=-2;c<=intl;intn++){
    c=a+b;a=b;b=c
  }
  scale=os
  if(l==a)return intn
  c=a
  phinx2=c+sqrt(c*c-4*(-1)^intn)
  lph=l( (1+sqrt(5))/2 )
  pi=pi()
  l2=l*l
  a=0.5 #start guess
  os+=8
  for(scale=8;scale<=os;scale+=8){
    b=0
    eps=A^(2-scale)
    while(abs(a-b)>eps){
      b=a
      a=l+sqrt(l2-4*c(pi*(intn+a)))
      a/=phinx2
      a=l(a)/lph
    }
  }
  os-=8;scale=os;a/=1
  return intn+a
}

###from http://phodd.net/gnu-bc/code/intdiff.bc
### IntDiff.BC - numeric differentiation and integration of 
###              a single variable function
### Perform numerical integration and differentiation of a single variable function.
###    Numerical Integration
###    Numerical Differentiation
###    Guessing convergence limits 

define f(x) { return x^2 } # example - redefine in later code/bc session

# Numerically differentiate the global function f(x)
define dfxdx(x) {
  auto eps;
  eps = A^-scale
  scale *= 2
  x = (f(x+eps)-f(x-eps))/(2*eps)
  scale /= 2
  return x/1
}

# New global variable like 'scale' - determines accuracy of numerical
#   integration at the expense of time. Don't set above 15 unless this
#   is running on a really fast machine!
depth = 10

# Numerically integrate the global function f(x) between x = a and x = b
# . uses the trapezoidal rule
define ifxdx_old(a,b) {
  auto os,h,s,t,i
  if(a==b)return f(a)
  os = scale;if(scale<depth)scale=depth
  scale+=3
  h = 2^-depth
  if(b<a){i=b;b=a;a=i}
  s = (b - a) * h
  t =(f(a)+f(b))/2
  for(i=a+s;i<b;i+=s)t+=f(i)
  scale=os;return t*s/1
}

# Numerically integrate the global function f(x) between x = a and x = b
define ifxdx(a,b) {
  auto oib,od,os,s,s8,t,i,j,ni,fi,fis
  if(a==b)return f(a)
  od=depth;if(depth<3)depth=3
  os=scale;if(scale<(i=depth+depth))scale=i
  scale+=3
  if(b<a){i=b;b=a;a=i}
  s=(b-a)*(2^-depth)
  oib=ibase;ibase=A
  s8 = s*8
  fi = 989*f(a)
  for(i=a;i<b;i=ni){
    ni=j=i+s8;
    t+=   fi+(fis=989*f(j))
    t+= 5888*(f(i+=s)+f(j-=s))
    t-=  928*(f(i+=s)+f(j-=s))
    t+=10496*(f(i+=s)+f(j-=s))
    t-= 4540*f(i+=s)
    fi=fis
  }
  depth=od;scale=os
   t*=s*4/14175
  ibase=oib;return t
}

# glai - guess limit at infinity
#   Assumes p, q and r are 3 consecutive convergents to a limit and
#   attempts to extrapolate precisely what that limit is after an infinite 
#   number of iterations.

# 0 = glai returns function result only
# 1 = glai commentates on interesting convergents
glaitalk = 1

define glai(p,q,r) {
  auto m,n 
  m = q^2-p*r
  n = 2*q-p-r
  if(n==0)if(m==0){
   if(glaitalk)print "glai: Constant series detected\n"
   return p
  }else{
   if(glaitalk)print "glai: Arithmetic progression detected: limit is infinite\n"
   return 1/0
  }
  if(m==0){
   if(glaitalk)print "glai: Geometric progression detected: limit wraps to zero!\n"
   return 0
  }
  return m/n
}

# Examples:
#   glai(x,x+1,x+2) causes a division by zero error as the limit of
#                   an arithmetic progression is infinite
#   glai(a*k,a*k^2,a*k^3) returns zero! The limit of a geometric
#                         progression in p-adics is precisely that,
#                         and somehow this simple function 'knows'.
#   glai(63.9, 63.99, 63.999) returns 64 - correctly predicting the
#                             limit of the sequence.

# Run consecutive convergents to the ifxdx function through glai() 
#   attaining "better" accuracy with slightly fewer calculations
define ifxdx_g(a,b) {
  auto p,q,r
  depth-=3  ; p = ifxdx(a,b)
  .=depth++ ; q = ifxdx(a,b)
  .=depth++ ; r = ifxdx(a,b)
  .=depth++
  return glai(p,q,r)
}

#define f(x){if(x<=0)return 0;x=root(x,x);return x*(x-1)}
#zz=-0.10717762842559665710112408473270837028206726160094438


###from http://phodd.net/gnu-bc/code/interest.bc
###Early in 2011, Randy Rysavy, a visitor to this site, contacted me enquiring about the possibility of adding financial functions to GNU bc. He included some of his own sample code, which gave me the impetus to produce this suite. Randy's own functions aren't included here, although there are equivalents and many more besides.
###As in other places on this site, the list of functions is not entirely in alphabetical order so to introduce concepts in a more logical order.
###Functions here rely fairly heavily on exponential related functions found in funcs.bc.
###    Interest
###    Savings & Loan
###   Amortisation / Mortgage
###    Financial 
### Interest.BC - Compound interest, loan amortisation and compound savings
# requires funcs.bc for pow, root, lambertw*
## Conventions in this library

#* ic = initial capital
#* rate = interest rate in form 1+fraction where 0<fraction<1;#
#         Conversions are provided for percent and 'fraction' itself
#* nt = number of terms
#* fc = final capital
#* spt = subterms per term;
#        e.g. one might have nt=25 and spt=12 for a 25-year debt paid monthly
#* paym = payment to make to reduce debt to zero OR additional periodic savings capital
#* tpaym = total of all payments to reduce debt to zero given the above
#* *a__[] = an array parameter passed by reference to return an array of numbers

## Acknowledgement goes to Randy Rysavy for the suggestion to create this
#  library of functions, and who also provided some example code, which
#  - with my apologies to Randy - has not been used here.
#  All code has been derived from first principles in order to make sure
#  I was able to understand the underlying mathematics and to create and
#  manipulate the necessary formulae.

### Conversions for various interest rate formats

define percentage_to_rate(percent) {
  if(0>=percent||percent>=100){
    print "warning: given percentage is outside ]0..100[\n";
  }
  return 1+percent/100;
}
define fraction_to_rate(fraction) {
  if(0>=percent||percent>=100){
    print "warning: given fraction is outside ]0..1[\n";
  }
  return 1+fraction;
}
define rate_to_fraction(rate) {
  if(1>=rate||rate>=2){
    print "warning: given rate is outside ]1..2[\n";
  }
  return rate-1;
}
define rate_to_percentage(rate) {
  return rate_to_fraction(rate)*100;
}

### Compound Interest

# Parameters always given in order:
#   (fc, ic, rate, nt)
# although one or more will be missing

# Find final capital from initial at given rate and number of terms
define compound_fc(ic,rate,nt){
  return ic*pow(rate,nt)
}

# Find initial capital from final at given rate and number of terms
define compound_ic_from_fc(fc,rate,nt){
  return fc/pow(rate,nt)
}

# Find number of terms given rate and final and initial capital
define compound_nt_from_fc(fc,ic,rate){
  return l(fc/ic)/l(rate)
}

# Find rate given number of terms and final and initial capital
define compound_rate_from_fc(fc,ic,nt){
  return root(fc/ic,nt)
}

### Loan Amortisation - Assume payment occurs immediately after interest is added

# Parameters are always given in the order:
#   (*a__[], tpaym, paym, ic, rate, nt, spt)
# although one or more will be missing
# e.g. tpaym and paym never happen together
#
# N.B. ic/fc occur AFTER tpaym/paym here

## Basic Calculations

# Determine payment; +Interest-Payment, Once per term
define loan_paym(ic,rate,nt) {
  auto rn;
  rn = pow(rate, nt)
  return ic*rn*(rate-1)/(rn-1)
}

# Total payment over all terms based on interest and payment once per term
define loan_tpaym(ic,rate,nt) {
  auto rn;
  rn = pow(rate, nt)
  return nt*ic*rn*(rate-1)/(rn-1)
}

# Determine payment; +Interest-Payment, Multiple times per term
define loan_paym_split(ic,rate,nt,spt) {
  return loan_paym(ic,root(rate,spt),nt*spt)
}

# Total payment over all terms based on interest and payment multiple times per term
define loan_tpaym_split(ic,rate,nt,spt) {
  return loan_tpaym(ic,root(rate,spt),nt*spt)
}

# Generate an array of owed capital at each term
define loan_apaym(*a__[],ic,rate,nt){
  auto i,paym;
  paym = loan_paym(ic,rate,nt);
  a__[0]=ic;for(i=1;i<=nt;i++)a__[i]=a__[i-1]*rate-paym;
  a__[i]=0;
  return nt;
}

# Generate an array of owed capital at each subterm
define loan_apaym_split(*a__[],ic,rate,nt,spt) {
  auto i,paym;
  rate = root(rate, spt)
  nt *= spt;
  paym = loan_paym(ic,rate,nt);
  a__[0]=ic;for(i=1;i<=nt;i++)a__[i]=a__[i-1]*rate-paym;
  a__[i]=0;
  return nt;
}

## Reverse calculations

# Given the once-per-term payment, find the initial capital
define loan_ic_from_paym(paym,rate,nt) {
  auto rn;
  rn = pow(rate, nt)
  return paym*(rn-1)/((rate-1)*rn)
}

# Given the total of all once-per-term payments, find the initial capital
define loan_ic_from_tpaym(tpaym,rate,nt) {
  auto rn;
  rn = pow(rate, nt)
  return tpaym*(rn-1)/((rate-1)*rn*nt)
}

# Given the multiple-per-term payment, find the initial capital
define loan_ic_from_paym_split(paym,rate,nt,spt) {
  return loan_ic_from_paym(paym,root(rate,spt),nt*spt)
}

# Given the total of all multiple-per-term payments, find the initial capital
define loan_ic_from_tpaym_split(tpaym,rate,nt,spt) {
  return loan_ic_from_tpaym(tpaym,root(rate,spt),nt*spt)
}

# Given the once-per-term payment, find the interest rate
define loan_rate_from_paym(paym,ic,nt){
  auto os,i,k,rate,ratf,ratg,ratd;
  if(paym*nt==ic)return 1/1;
  k=paym/ic;
  rate=root(k*nt,nt/2); # good initial guess
  os=scale;scale+=scale
  for(i=scale;i>1;i/=2){
    # use of rat plus d, (e,) f, and g is a deliberate pun on 'rate'
    ratf=1+k*(1-pow(rate,-nt));# f and g are iterated approximants
    ratg=1+k*(1-pow(ratf,-nt));
    ratd=(ratf+ratf-rate-ratg);# d is a divisor that could end up as 0
    if(ratd==0){rate=1;break}  # so escape if that happens
    rate=(ratf*ratf-rate*ratg)/ratd;# glai(rate,ratf,ratg)
    # this trick causes the iteration to converge exponentially rather
    # than geometrically as found by repeating ratf=...;rate=ratf
  }
  scale=os;return rate/1
}

# Given the total of all once-per-term payments, find the interest rate
define loan_rate_from_tpaym(tpaym,ic,nt) {
  return loan_rate_from_paym(tpaym/nt,ic,nt);
}

# Given the multiple-per-term payment, find the interest rate
define loan_rate_from_paym_split(paym,ic,nt,spt) {
  return pow(loan_rate_from_paym(paym,ic,nt*spt),spt);
}

# Given the total of all multiple-per-term payments, find the interest rate
define loan_rate_from_tpaym_split(tpaym,ic,nt,spt) {
  return pow(loan_rate_from_tpaym(tpaym,ic,nt*spt),spt);
}

# Given the once-per-term payment, find the number of terms
define loan_nt_from_paym(paym,ic,rate) {
  auto d;
  d=paym-ic*(rate-1);
  return l(paym/d)/l(rate)
}

# Given the total of all once-per-term payments, find the number of terms
define loan_nt_from_tpaym(tpaym,ic,rate) {
  auto q,l;
  q = tpaym/(ic*(rate-1));
  l = l(rate);
  return q + lambertw0(-q*l/pow(rate,q))/l
}

# Given the multiple-per-term payment, find the number of terms
define loan_nt_from_paym_split(paym,ic,rate,spt) {
  return loan_nt_from_paym(paym,ic,root(rate,spt))/spt
}

# Given the total of all multiple-per-term payments, find the number of terms
define loan_nt_from_tpaym_split(tpaym,ic,rate,spt) {
  return loan_nt_from_tpaym(tpaym,ic,root(rate,spt))/spt
}

# Given the payment, determine the number of subterms within the term
define loan_spt_from_paym(paym,ic,rate,nt) {
  auto rn;
  rn = pow(rate, nt)
  return l(rate)/l(1+paym*(rn-1)/(ic*rn));  
}

# Given the total of all payments, determine the number of subterms within the term
define loan_spt_from_tpaym(tpaym,ic,rate,nt) {
  auto q,l,rn,temp;
  rn = pow(rate, nt)
  l = l(rate);
  q = nt*ic*rn/(tpaym*(rn-1));
  return -1/(q + lambertw_1(-q*l/pow(rate,q))/l);
}

### Savings - Assume interest is added before extra payment is added

# Parameters here are always given in the order:
#   (*a__[], fc, ic, tpaym, paym, rate, nt, spt)
# although one or more will be missing
# e.g. ic and fc never happen together
#
# N.B. ic/fc occur BEFORE tpaym/paym here

# Determine final captial savings given initial lump sum, regular payment,
# . interest rate and number of terms (+Interest+Payment)
define saving_fc(ic,paym,rate,nt){
  auto rn;
  rn = pow(rate,nt);
  return ic*rn+paym*(rn-1)/(rate-1)
}

# As above but assumes terms are split into subterms
define saving_fc_split(ic,paym,rate,nt,spt){
  return saving_fc(ic,paym,root(rate,spt),nt*spt)
}

# Generate an array of current capital at each term
define saving_afc(*a__[],ic,paym,rate,nt){
  auto i;
  a__[0]=ic;for(i=1;i<=nt;i++)a__[i]=a__[i-1]*rate+paym;
  a__[i]=0;
  return nt;
}

# Generate an array of current capital at each subterm
define saving_afc_split(*a__[],ic,paym,rate,nt,spt) {
  auto i;
  rate = root(rate, spt);
  nt *= spt;
  #paym = loan_paym(ic,rate,nt);
  a__[0]=ic;for(i=1;i<=nt;i++)a__[i]=a__[i-1]*rate+paym;
  a__[i]=0;
  return nt;
}

## Reverse calculations - given final capital and all but one of the others,
##                        determine the value of the missing parameter

# Determine initial capital (savings starter lump sum) based on final capital
define saving_ic_from_fc(fc,paym,rate,nt) {
  auto rn;
  rn = pow(rate,nt);
  return (fc-paym*(rn-1)/(rate-1))/rn;
}

# as above only with specified number of subterms per term
define saving_ic_from_fc_split(fc,paym,rate,nt,spt) {
  return saving_ic_from_fc(fc,paym,root(rate,spt),nt*spt)
}

# Determine regular payment based on desired final capital and initial lump sum
define saving_paym_from_fc(fc,ic,rate,nt) {
  auto rn;
  rn = pow(rate,nt);
  return (fc-ic*rn)*(rate-1)/(rn-1)
}

# as above only with specified number of subterms per term
define saving_paym_from_fc_split(fc,ic,rate,nt,spt){
  return saving_paym_from_fc(fc,ic,root(rate,spt),nt*spt)
}

# Determine ideal interest rate for given initial and final conditions
define saving_rate_from_fc(fc,ic,paym,nt) {
  auto os,i,ratd,rate,ratf,ratg;
  rate = root(fc/(ic+nt*paym),nt) # good initial guess
  os=scale;scale+=scale
  for(i=scale;i>1;i/=2){
    ratf=root((fc*(rate-1)+paym)/(ic*(rate-1)+paym),nt)
    ratg=root((fc*(ratf-1)+paym)/(ic*(ratf-1)+paym),nt)
    ratd=(ratf+ratf-rate-ratg);# d is a divisor that could end up as 0
    if(ratd==0){rate=1;break}  # so escape if that happens
    rate=(ratf*ratf-rate*ratg)/ratd;# glai(rate,ratf,ratg)
  }
  scale=os;return rate/1
}

# as above only with specified number of subterms per term
define saving_rate_from_fc_split(fc,ic,paym,nt,spt) {
  return pow(saving_rate_from_fc(fc,ic,paym,nt*spt),spt)
}

# Determine number of compounding terms required for desired final capital
define saving_nt_from_fc(fc,ic,paym,rate){
  return l( (fc*(rate-1)+paym)/(ic*(rate-1)+paym) )/l(rate)
}

# as above only with specified number of subterms per term
define saving_nt_from_fc_split(fc,ic,paym,rate,spt) {
  return saving_nt_from_fc(fc,ic,paym,root(rate,spt))/spt
}

# Determine number of subterms per term based on other details
define saving_spt_from_fc(fc,ic,paym,rate,nt) {
  auto rn;
  rn = pow(rate,nt);
  return l(rate)/l(1+paym*(rn-1)/(fc-ic*rn));
}

###from http://phodd.net/gnu-bc/code/logic.bc
### Logic.BC -  Do bitwise functions with GNU bc
### A large suite of functions to perform bitwise functions such as AND, OR, NOT and XOR. Uses twos complement for negative numbers, unlike previous versions of this file, which had no support at all.
### Some of the functions here will use the global bitwidth variable, which itself is initialised as part of this file, to emulate byte/word sizes found in most computers. If this variable is set to zero, an infinite bitwidth is assumed.
### Many functions will display a warning if there is suspicion that a secondary floating point representation of a number has been generated, e.g. 1.1111... is an SFPR of 10.0000...; These warnings can be disabled by setting the global variable sfpr_warn to 0 (default is 1). 
# Twos complement is assumed for negative numbers
#  this avoids awkward problems like negative zero
###    Fixed word size
###    Infinite word size
###    Common bitwise
###    Twos complement
###    Bit shifting
###    Gray code
###    'Multiplication'
###    Floating point
###    Floating point + 'Multiplication'
###    Gray code + Floating Point 
## Word size handling

# Global variable like 'scale' or 'length'
#  When zero, bitwidth is assumed to be infinite
bitwidth=0

# to be used by functions reliant on bitwidth
define checkbitwidth_() {
  auto os;os=scale;scale=0;bitwidth/=1;scale=os
  if(bitwidth<0){
    print "Negative bitwidth, set to 0\n"
    bitwidth=0
  }
  return 0;
}

# returns bitwidth of a variable
#  (is a simplified version of digits() function in digits.bc)
define bitwidth(x) {
  auto os,p,c;
  os=scale;scale=0;x/=1
   if(x<0){x=-x}
   c=0;p=1;while(p<=x){.=c++;p+=p}
  scale=os;return(c)
}

# cast signed values into unsigned values
define unsign(x) {
  auto os,z; x+=checkbitwidth_()
  os=scale;scale=0
  x/=1
  if(x<0){
    if(bitwidth==0){
      x+=2^(bitwidth(x)+1)
    }else{
      x+=2^(bitwidth+1)
    }
  }
  if(bitwidth)x%=2^bitwidth
  scale=os;return x;
}

# cast unsigned values into signed values
define resign(x) {
  auto os,t; x+=checkbitwidth_()
  os=scale;scale=0
  x/=1
  if(bitwidth==0||x<0){scale=os;return x}
    # can't do anything when bitwidth is infinite or x already has a sign!
  x%=(t=2^bitwidth)
  if(x+x>=t)x-=t
  scale=os;return x;
}

## Common bitwise

# Perform a bitwise logical NOT of x
#  not the same as removing the sign!
define not(x) {
  x=-x;return --x # x=-1-x
}

# Perform a bitwise logical AND of x and y
define and(x,y) {
 auto n,z,t,a,b,c,os,qx,qy;
 os=scale;scale=0
 n=0;x/=1;y/=1
 if(x<0){
   if(y<0){scale=os;return -1-or(-1-x,-1-y)}# not(or(not(x),not(y)))
   x=-1-x;n=1
 }
 if(y<0){t=-1-y;y=x;x=t;n=1}
 z=0;t=1;while(x||y){
  qx=x/4;qy=y/4
  a=x-4*qx;if(n)a=3-a
  if((c=a)!=(b=y-4*qy))if((c+=b-3)<0)c=0
  z+=t*c # doing calculations in base 4 is faster
  t*=4;x=qx;y=qy
 }
 scale=os;return (z)
}

# Perform a bitwise logical OR of x and y
define or(x,y) {
 auto z,t,a,b,c,os,qx,qy;
 os=scale;scale=0
 x/=1;y/=1
 if(x<0||y<0){scale=os;return -1-and(-1-x,-1-y)}# not(and(not(x),not(y)))
 z=0;t=1;while(x||y){
  qx=x/4;qy=y/4
  if((c=a=x-4*qx)!=(b=y-4*qy))if((c+=b)>3)c=3
  z+=t*c # doing calculations in base 4 is faster
  t*=4;x=qx;y=qy
 }
 scale=os;return (z)
}

  ## NB: and() and or() are mutually reliant
  ##     though not mutually recursive
  ##     Both could also be reliant on not()
  ##     but this has be avoided

# Perform a bitwise logical EXCLUSIVE-OR of x and y
define xor(x,y) {
 auto n,z,t,a,b,c,os,qx,qy;
 os=scale;scale=0
 n=0;x/=1;y/=1
 if(x<0){x=-1-x;n=!n}
 if(y<0){y=-1-y;n=!n}
 z=0;t=1;while(x||y){
  qx=x/4;qy=y/4;
  c=(a=x-4*qx)+(b=y-4*qy) # doing calculations in
  if(!c%2)c=a+4-b         # base 4 is faster
  z+=t*(c%4)
  t*=4;x=qx;y=qy
 }
 if(n)z=-1-z
 scale=os;return (z)
}

## Bit shifting

# Reverse bits in x
define bitrev(x) {
 auto os,z,w,h; x+=checkbitwidth_()
 os=scale;scale=0
 x/=1;w=bitwidth
 if(x<0){
   if(w==0){scale=os;return -1}
   scale=os
   return -bitrev(-x-1)-1 #not(bitrev(not(x)))
 }
 if(w)x%=2^w
 z=0;for(.=.;x||w>0;w--){h=x/2;z+=z+x-h-h;x=h}
 scale=os;return(z)
}

# Perform a LEFT-SHIFT of x by n places
define shl(x,n) {
 auto os,w,s; x+=checkbitwidth_()
 if(n<0)return shr(x,-n)
 s=1;if(x<0){s=-1;x=-x}
 os=scale;scale=0
  x/=1;x*=2^(n/1)
  if(bitwidth)if(x>=(w=2^bitwidth))x%=w
 scale=os;return s*x
}

# Perform a RIGHT-SHIFT of x by n places
define shr(x,n) {
 auto os
 if(n<0)return shl(x,-n)
 os=scale;scale=0
  x/=2^(n/1)
 scale=os;return x
}

define rol(x,n) {
  auto os,s,w,t; x+=checkbitwidth_();
  if(n<0)return ror(x,-n);
  os=scale;scale=0
   x/=1;if(w=bitwidth)n%=w
   s=1;if(x<0){x=-1-x;s=-1}
   x*=2^(n/1)
   if((w=2^w)==1){
     if(s<0)x=-1-x;
     scale=os;return x
   }
   t=x%w;x=t+(x-t)/w
   if(s<0)x=w-1-x
   if(x+x>=w)x-=w
  scale=os;return x;
}

define ror(x,n) {
  auto os,s; x+=checkbitwidth_();
  if(n<0)return rol(x,-n);
  if(bitwidth)return rol(x,bitwidth-n)
  os=scale;scale=0
   x/=1;n=2^(n/1)
   s=1;if(x<0){x=-1-x;s=-1}
   if(x%n){
     # low order 1s cannot roll to infinite high order positions where
     # 0s should be without invoking a class of infinities
     print "ror: can't rotate low order bits to infinity\n"
     scale=os;return s*(A^scale-1)
   }
   x/=n
   if(s<0)x=-1-x
  scale=os;return x
}

## Gray Code

# Convert a value to its graycode equivalent
define graycode(x) {
  auto n;
  n=0;if(x<0){n=1;x=-1-x}
  x=xor(x,x/2)
  if(n)x=-1-x
  return x
}

# Inverse of graycode
define inverse_graycode(x) {
  auto os,n,a[],b,i,y,hx
  os=scale;scale=0
   x/=1;n=0;if(x<0){n=1;x=-1-x}
   for(i=0;x;i++){hx=x/2;a[i]=x-hx-hx;x=hx}
   y=0;b=0;for(--i;i>=0;i--)y+=y+(b=(b!=a[i]))
   if(n)y=-1-y
  scale=os;return y
}

# Reverse all digits after the first digit
# . is a self inverse permutation of integers
define ungraylike1(x) {
  auto os,ob;
  if(x<0)return -1-ungraylike1(-1-x);
  if(x<1)return 0;
  if(x<2)return 1;
  os=scale;scale=0
   ob=bitwidth;bitwidth=bitwidth(x/=1)-1;
    x=2^bitwidth+bitrev(x);
   bitwidth=ob
  scale=os;return x
}

# Reverse and complement all digits after the first digit
# . is a self inverse permutation of integers
define ungraylike2(x) {
  auto os,ob;
  if(x<0)return -1-ungraylike2(-1-x);
  if(x<1)return 0;
  if(x<2)return 1;
  os=scale;scale=0
   ob=bitwidth;bitwidth=bitwidth(x/=1)-1;
    x=2^(bitwidth+1)-1-bitrev(x);
   bitwidth=ob
  scale=os;return x
}

## Hamming Distance

define hamming(x,y) {
  auto os,a,b,t;
  os=scale;scale=0;x/=1;y/=1
  if(bitwidth){
    if(x<0||y<0)b=2^bitwidth
    if(x<0)x=(b+b+x)%b #x=unsign(x)
    if(y<0)y=(b+b+y)%b #y=unsign(y)
  } else {
    if(x<0&&y<0){x=-1-x;y=-1-y}
    if(x<0||y<0){
      print "hamming: infinite distance from mismatched signs\n";
      b=os;b*=D*D+A*A;b/=9*9 # approximate nearest power of 2 to A^os
      scale=os;return 2^b-1
    }
  }
  t=0;while(x||y){if((a=x%4)!=(b=y%4))t+=1+(a+b==3);x/=4;y/=4}
  scale=os;return t
}

## 'Multiplication'

# NB: none of these are equivalent to nim multiplication

# Perform bitwise logical OR 'multiplication' of x and y
define orm(x,y){
  auto os,s,z,hy;
  os=scale;scale=0
  x/=1;y/=1;s=1;if(x<0){x=-x;s=-s};if(y<0){y=-y;s=-s}
  z=0;while(y){hy=y/2;if(y-hy-hy)z=or(z,x);x+=x;y=hy}
  scale=os;return z*s
}

# Perform bitwise logical EXCLUSIVE-OR 'multiplication' of x and y
define xorm(x,y){
  auto os,s,z,hy;
  os=scale;scale=0
  x/=1;y/=1;s=1;if(x<0){x=-x;s=-s};if(y<0){y=-y;s=-s}
  z=0;while(y){hy=y/2;if(y-hy-hy)z=xor(z,x);x+=x;y=hy}
  scale=os;return z*s
}

# NB: Logical AND 'multiplication' is problematic and not included here
# see logic_andm.bc for alternatives

## Floating point

# Workhorse for the below; Bitwise multiplier
bw_mult_ml_ = 1
bw_mult_sc_ = 0
define bw_mult_(sc) {
  if(bw_mult_sc_!=sc)bw_mult_ml_=2^bitwidth(A^(bw_mult_sc_=sc))
  return 8*bw_mult_ml_
}

sfpr_check_mod_ = 2^5 # power of two = number of bits to warn on
sfpr_check_max_ = sfpr_check_mod_*(.5*sfpr_check_mod_+1)-1 #1000011111

# Set to 0 to stop warnings about sfprs
sfpr_warn = 1

# Check if x contains a secondary floating point representation of a number
# e.g. 0.11111... = sfpr of 1.00000...
define is_sfpr_(x) {
  if(x==0)return 0;
  x/=sfpr_check_mod_
  if(x<0)x=-x;
  if(x>=sfpr_check_max_)
   if(x%sfpr_check_mod_==sfpr_check_mod_-1)
     return 1;
  return 0;
}

# used to check whether parameters and output are sfprs
define is_any_sfpr3_(x,y,z) {
  if(sfpr_warn){
   if(is_sfpr_(x))return 1;
   if(is_sfpr_(y))return 1;
   if(is_sfpr_(z))return 1;
  }
  return 0;
}

define sfpr_warn_msg_() {
  print ": 2ndary fp representation of rational\n"
  return 0;
}

# Perform XOR on binary floating point representations of x and y
define xorf(x,y){
 auto os,t
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t
  z=xor(x,y)
  if(is_any_sfpr3_(x,y,z)){print "xorf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

# Perform OR on binary floating point representations of x and y
define orf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t
  z=or(x,y)
  if(is_any_sfpr3_(x,y,z)){print "orf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

# Perform AND on binary floating point representations of x and y
define andf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t
  z=and(x,y)
  if(is_any_sfpr3_(x,y,z)){print "andf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

## Floating point + 'Multiplication'

# Perform XOR-M on binary floating point representations of x and y
define xormf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t;t*=t
  z=xorm(x,y)
  if(is_any_sfpr3_(x,y,z)){print "xormf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

# Perform OR-M on binary floating point representations of x and y
define ormf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t;t*=t
  z=orm(x,y)
  if(is_any_sfpr3_(x,y,z)){print "ormf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

# NB: Bitwise logical AND 'multiplication' would always return 0
# see logic_andm.bc for alternatives

## Gray Code + Floating Point

define graycodef(x) {
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t
  z=graycode(x)
  if(is_any_sfpr3_(x,0,z)){print "graycodef";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

define inverse_graycodef(x) {
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t
  z=inverse_graycode(x)
  if(is_any_sfpr3_(x,0,z)){print "inverse_graycodef";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

###from http://phodd.net/gnu-bc/code/logic_andm.bc
### Logic-ANDM.BC
### Attempts to create bitwise AND multiplications that do not result in zero

# NB: none of these are equivalent to nim multiplication

# Most functions here are asymmetric. f(x,y) does not necessarily equal f(y,x)

# Perform bitwise logical AND 'multiplication' of x and y ???

define x1andm(x,y){
  return xor(xorm(x,y),orm(x,y))
}

define x2andm(x,y){
  return xorm(xor(x,y),or(x,y))
}

define andm(x,y){
  auto os,s,z,hy;
  os=scale;scale=0
  x/=1;y/=1;s=1;if(x<0){x=-x;s=-s};if(y<0){y=-y;s=-s}
  if(x<y){x+=y;y=x-y;x-=y}
  z=x*(y%2);while(z&&y){hy=y/2;if(y-hy-hy)z=and(z,x);x+=x;y=hy}
  scale=os;return z*s
}

# Perform AND-M on binary floating point representations of x and y ???

define x1andmf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t;t*=t
  z=x1andm(x,y)
  if(is_any_sfpr3_(x,y,z)){print "x1andmf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

define x2andmf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t;t*=t
  z=x2andm(x,y)
  if(is_any_sfpr3_(x,y,z)){print "x2andmf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

define andmf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t;t*=t
  z=andm(x,y)
  if(is_any_sfpr3_(x,y,z)){print "andmf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}


###from http://phodd.net/gnu-bc/code/logic_inverse.bc
### Logic_Inverse.BC - Inverses for bitwise AND and OR
###  Calculation of possible inputs to bitwise AND and OR functions in order to achieve a specific output, i.e. find inverses, where possible, to bitwise functions. 
###    Inverse bitwise functions 
# Negative numbers not yet supported

# Global variable to control no-solution warning messages
# 0 -> warnings suppressed; 1 -> show warnings
# (Some errors are fatal and cannot be suppressed)
dand_sor_warn_=1

# Workhorse function for the below
define dand_sor_(which, z,y ,n){
  auto x,t,os,hz,hy,hn,b,str;
  os=scale;scale=0
  z/=1;y/=1;n/=1
  if(n<-4||z<0||y<0){
    if(which==2||which==3){print "striped_";which-=2}
    if(which==0)print "dand: "
    if(which==1)print "sor: "
    if(z<0||y<0){print "negative unsupported\n";n=0}
    if(n<-4)print "unknown option for n\n"
    scale=os;return -1
  }
  str=-1;if(which==2||which==3)str=which-2
  x=0;t=1;while(z||y){
    hz=z/2;hy=y/2
    # Set b to be the bit in the result
    # Unless altered by n==-4:
    # b == 0 => actual zero bit
    # b == 1 => actual one but
    # b == 2 => don't-care/both bit. Could be either 1 or 0. Choice set by n parameter.
    # b == 3 => failure/neither bit. There are no solutions
    if(which==0||str==0){b=1-y+hy+hy;b+=b+z-hz-hz}
    if(which==1||str==1){b=z-hz-hz;if(y-hy-hy)b=3-b}
    if(which==2||which==3)str=!str
    if(n==-4||n==-3){
      if(n==-4)if(++b==4)b=0
      x+=t*b
      t*=4
    } else if(n==-2||n==-1) {
      if(b==3){
        scale=os
        if(n==-1){
          if(dand_sor_warn_){
            if(which==2||which==3){print "striped_";which-=2}
            if(which==0)print "dand: "
            if(which==1)print "sor: "
            print "no possible solutions\n"
          }
          return -1
        } else {
          return 0
        }
      }
      if(b==2).=x++
    } else {
      if(b==3){
        scale=os
        if(dand_sor_warn_){
          if(which==2||which==3){print "striped_";which-=2}
          if(which==0)print "dand: "
          if(which==1)print "sor: "
          print "no possible solutions\n"
        }
        return -1
      }
      if(b==2){hn=n/2;b=n-hn-hn;n=hn}
      x+=t*b
      t+=t
    }
    z=hz;y=hy
  }
  if(n==-2)x=2^x
  scale=os;return x
}

# n parameter options:
#  n == -4 => base 4 codification: {neither,0,1,both} <=> {0,1,2,3}
#  n == -3 => base 4 codification: {0,1,both,neither} <=> {0,1,2,3} (default)
#  n == -2 => returns number of solutions = N
#  n == -1 => returns number of don't-care bits = D
#             = log2(number of solutions) = log2(N) or -1 if no solution
#  n >=  0 => returns solution specified by n mod N or -1 if no solution
# Hint:
#  n ==  0 => guaranteed to return a solution (the smallest possible)
#             if one exists

# DivAND / De-AND
# Bitwise division in the sense that bitwise AND is bitwise multiplication
# Attempt to find solutions to z = and(x,y) for x
# . any error will cause the return of -1
define dand(z,y ,n) { return dand_sor_(0, z,y, n) }

# SubtractOR / SubtORct
# Bitwise subtraction in the sense that bitwise OR is bitwise addition
# Attempt to find solutions to z = and(x,y) for x
# . any error will cause the return of -1
define  sor(z,y ,n) { return dand_sor_(1, z,y, n) }

# N.B. There is no bitwise XOR subtraction in the style of the above
# since XOR is its own inverse.

# Striped DivAND / De-AND
# Bitwise division in the sense that bitwise AND is bitwise multiplication
# Attempt to find solutions to z = and(x,y) for x
# . any error will cause the return of -1
define striped_dand(z,y ,n) { return dand_sor_(2, z,y, n) }

# Striped SubtractOR / SubtORct
# Bitwise subtraction in the sense that bitwise OR is bitwise addition
# Attempt to find solutions to z = and(x,y) for x
# . any error will cause the return of -1
define  striped_sor(z,y ,n) { return dand_sor_(3, z,y, n) }

# Workhorse print function
define print_01dx_(x){
  auto os,ai,ni,a[],aai,f2,f3;
  os=scale;scale=0;
  x/=1;if(x<0)x=-x
  ai=0;f3=0;ni=i=x
  while(i){i=ni;ni=i/4;a[++ai]=aai=i-ni*4}
  if(!ai){print 0;scale=os;return i}
  for(--ai;ai;ai--){
    i=a[ai]
    if(i==0){print 0}else if(i==1){print 1
    }else if(i==2){print"d";.=f2++}else{print"X";.=f3++}
  }
  if(f3){
    print " => no solution; ",f3," fail bit"
    if(f3>1)print"s"
  }else{
    f2=2^f2
    print " => ",f2," solution"
    if(f2>1)print"s"
  }
  scale=os;return x
}

define dand_print(z,y) { .=print_01dx_(dand_sor_(0, z,y, -3)) }
define sor_print(z,y)  { .=print_01dx_(dand_sor_(1, z,y, -3)) }
define striped_dand_print(z,y) { .=print_01dx_(dand_sor_(2, z,y, -3)) }
define striped_sor_print(z,y)  { .=print_01dx_(dand_sor_(3, z,y, -3)) }

###from http://phodd.net/gnu-bc/code/logic_otherbase.bc
### Logic-OtherBase.BC - Attempt to extend bitwise functions into other bases
 # see logic.bc for faster bitwise-only functions
## XOR like
# All of these degenerate to being identical
# to bitwise exclusive-or in base 2

# Workhorse function for the others
define digitwise_xor_(which, base, x,y) {
  auto os,n,a,b,c,p,t,z,oddbase,h
  os=scale;scale=0
  /* Nonsense to delete
  # some algorithms are asymmetric. negative which swaps parameters
  if(which<0){x+=y;y=x-y;x-=y;which=-which} #swap
   # ^technically a bug since -0 fails, but that algorithm is symmetric anyway
  # since some algos are asym, add the alternatives in a ratio
  # . specified by the fractional part of which
  if(which>(z=which/1)){
    a=which-z
    z=digitwise_xor_(z,base,x,y)*(1-a)+digitwise_xor_(z,base,y,x)*a
    scale=os;return z
  }
  */
  which/=1
  base/=1;if(base<2)base=ibase
  n=0;x/=1;y/=1
  if(x<0){x=-1-x;n=!n}
  if(y<0){y=-1-y;n=!n}
  oddbase=base%2
  z=0;t=1;p=0;while(x||y){
    a=x-base*(h=x/base);x=h
    b=y-base*(h=y/base);y=h
    if(0){
    } else if(which==-1){
      c=a-b;if(c<0)c=-c
      if(c+c>base)c=base-c
    } else if(which==0){
      c=a-b;if(c<0)c=-c
    } else if(which==1){
      c=a+base-b;c%=base
    } else if(which==2){
      c=a+b;c%=base
    } else if(which==3){
      c=a+b
      if(oddbase||!c%2)c=a+base-b # odd base, or even base with odd parity
      c%=base
    } else if(which==4){
      c=a;b=b%2
      if((!oddbase&&b)||(oddbase&&p))c=base-1-a
      if(oddbase&&b)p=1-p
    }    
    z+=t*c
    t*=base
  }
  if(n)z=-1-z
  scale=os;return z
}

# Digitwise shortest distance
#  each digit is the shortest path from digit
#  in x to digit in y modulo the base
#   e.g. shortest distance between 0 and 4 modulo 6 is 2 (not 4)
define digitwise_sdist(base, x,y) {
  return digitwise_xor_(-1,base,x,y)
}

# Digitwise logical difference
define digitwise_diff(base, x,y) {
  return digitwise_xor_(0,base,x,y)
}

# Digitwise modulo subtraction; no borrows
#  asymmetric since x-y != y-x
define no_borrow_diff(base, x,y) {
  return digitwise_xor_(1,base,x,y)
}

# Digitwise modulo sum / add ignoring carries
define no_carry_add(base, x,y) {
  return digitwise_xor_(2,base,x,y)
}

# A logical 'blend' of the previous two functions
#  also asymmetric
define asym_mixor(base, x,y) {
  return digitwise_xor_(3,base,x,y)
}

# Flip digits of x using parity of digits of y
#  necessarily asymmetric
define asym_parity(base, x,y) {
  return digitwise_xor_(4,base,x,y)
}

## AND-like
# Positive values only for now

define digitwise_modmult(base, x,y) {
  auto os,a,b,c,t,z,h
  os=scale;scale=0
  base/=1;if(base<2)base=ibase
  x/=1;y/=1
  if(x<0||y<0){
    print "digitwise_modmult: unimplemented for -ve numbers\n"
    scale=os;return 0
  }
  z=0;t=1;while(x||y){
    a=x-base*(h=x/base);x=h
    b=y-base*(h=y/base);y=h
    c=(a*b)%base
    z+=t*c
    t*=base
  }
  scale=os;return z
}

define digitwise_min(base, x,y) {
  auto os,a,b,c,t,z,h
  os=scale;scale=0
  base/=1;if(base<2)base=ibase
  x/=1;y/=1
  if(x<0||y<0){
    print "digitwise_min: unimplemented for -ve numbers\n"
    scale=os;return 0
  }
  z=0;t=1;while(x||y){
    a=x-base*(h=x/base);x=h
    b=y-base*(h=y/base);y=h
    c=a;if(a>b)c=b
    z+=t*c
    t*=base
  }
  scale=os;return z
}

## OR like

define digitwise_max(base, x,y) {
  auto os,a,b,c,t,z,h
  os=scale;scale=0
  base/=1;if(base<2)base=ibase
  x/=1;y/=1
  if(x<0||y<0){
    print "digitwise_max: unimplemented for -ve numbers\n"
    scale=os;return 0
  }
  z=0;t=1;while(x||y){
    a=x-base*(h=x/base);x=h
    b=y-base*(h=y/base);y=h
    c=a;if(a<b)c=b
    z+=t*c
    t*=base
  }
  scale=os;return z
}

define digitwise_tlumdom(base, x,y) {
  auto os,a,b,c,t,z,h
  os=scale;scale=0
  base/=1;if(base<2)base=ibase
  x/=1;y/=1
  if(x<0||y<0){
    print "digitwise_tlumdom: unimplemented for -ve numbers\n"
    scale=os;return 0
  }
  z=0;t=1;while(x||y){
    a=x-base*(h=x/base);x=h
    b=y-base*(h=y/base);y=h
    c=base-1-((a+1)*(b+1))%base
    z+=t*c
    t*=base
  }
  scale=os;return z
}

## Gray Code like

define base_graycode(base,x){
  auto os,n,b2,b_1,d,p,g,h;
  os=scale;scale=0
  base/=1;if(base<2)base=ibase
  x/=1;n=0;if(x<0){n=1;x=-1-x}
  b2=base+base;b_1=base-1
  g=0;p=1
  while(x){
    if(x%b2>(d=x-base*(h=x/base)))d=b_1-d
    g+=p*d;p*=base;x=h
  }
  if(n)g=-1-g
  scale=os;return g
}

define inverse_base_graycode(base,x) {
  auto os,n,bp,b_1,a[],b,i,y,h;
  os=scale;scale=0
   base/=1;if(base<2)base=ibase
   x/=1;n=0;if(x<0){n=1;x=-1-x}
   for(i=0;x;i++){a[i]=x-base*(h=x/base);x=h}
   bp=base%2;b_1=base-1
   y=0;b=0;for(--i;i>=0;i--){
     d=a[i];if(b)d=b_1-d
     y=y*base+d
     if(bp){b+=d}else{b=d}
     b%=2
   }
   if(n)y=-1-y
  scale=os;return y
}

## Hamming Distance

# Count the number of differences between two numbers in the given base
# . compare with digit_distance in digits.bc which
# . takes the value of the difference into account
define base_hamming(base,x,y) {
  auto os,t,hx,hy;
  os=scale;scale=0;base/=1;x/=1;y/=1
  if(base<2)base=ibase
  if(x<0&&y<0){x=-1-x;y=-1-y}
  if(x<0||y<0){
    print "base_hamming: infinite distance from mismatched signs\n";
    scale=os;return A^os-1
  }
  t=0;while(x||y){hx=x/base;hy=y/base;if(x-y!=base*(hx-hy)).=t++;x=hx;y=hy}
  scale=os;return t
}

###from http://phodd.net/gnu-bc/code/logic_striping.bc
### Logic-Striping.BC -  Do striped bitwise functions with GNU bc
  ## To be used with Logic.BC
###A family of functions related to the bitwise functions which may be useful for encryption and hashing. Then again they might not. See the text documentation for more technical information.
###These were separated from the main logic.bc due to being of questionable worth, but were given their own file as they are still interesting functions. The latter file is required for these functions to work correctly.
###    Bitwise striping 
## Basic Striping

# workhorse function for striped_and() and striped_or()
#  Matching bit positions in x and y are inherited by the result
#  Mismatched bits are arbitrated by their bit position and the b parameter
#   When the b parameter is 0, even bit positions
#    (LSB being 0 and thus even) are set to 0, odd positions are set to 1
#    This is a Striped AND;
#     The degenerate case for a single bit is equivalent to AND
#   When the b parameter is 1, even bit positions
#    (LSB being 0 and thus even) are set to 1, odd positions are set to 0
#    This is a Striped OR;
#     The degenerate case for a single bit is equivalent to OR
define stripe_(b,x,y){
 auto z,t,os,hx,hy;
 os=scale;scale=0
 x/=1;y/=1;b=!!b
 if((x<0&&y>=0)||(y<0&&x>=0)){
   print "striped_"
   if(b){print "or"}else{print "and"}
   print ": sign mismatch\n"
   # Any return value here would be related to a
   # divergent sum with 'impossible' value -1/3
   scale=os;return 0;
 }
 if(x<0){scale=os;return -1-stripe_(!b,-1-x,-1-y)}# not(stripe_(!b,not(x),not(y)))
 z=0;t=1;while(x||y){
  hx=x/2;hy=y/2
  if((x-hx-hx!=b&&y-hy-hy!=b)!=b)z+=t
  t+=t;b=!b;x=hx;y=hy
 }
 scale=os;return (z)
}

# Perform a bitwise logical STRIPED-AND of x and y
define striped_and(x,y) { return stripe_(0,x,y) }

# Perform a bitwise logical STRIPED-OR of x and y
define striped_or(x,y)  { return stripe_(1,x,y) }

# Generalisation of the stripe functions
#   genstripe(0,2,x,y) == and(x,y)
#   genstripe(0,3,x,y) ==  or(x,y)
#   genstripe(0,5,x,y) == striped_or(x,y)
#   genstripe(0,6,x,y) == striped_and(x,y)
#  Override and Repeat parameters should be of binary form
#   "1 followed by bit pattern"
#   e.g. repeat of binary 110 = decimal 6 implies pattern of
#    ...101010101010 which is the bit pattern for striped_and
#   Some patterns are equivalent e.g. 110 and 11010
#  Override parameter is used override the repeat pattern
#   on the lower order bits
define genstripe(override,repeat,x,y){
 auto o,r,b,z,t,os,h,hx,hy;
 os=scale;scale=0
 x/=1;y/=1;override/=1;repeat/=1

 if(override<0)override=-override
 if(override<2)override+=2
 if(repeat  <0)repeat  =-repeat
 if(repeat  <2)repeat  +=2

 # work out whether the and() or or() functions - which support
 #   parameters of opposing sign - are more appropriate
 #r=repeat;r+=r%2;z=0;for(r/=2;r>1;r/=2)if(z=r%2)break;
 r=repeat;h=r/2;r+=(t=r-h-h)
 z=0;for(r=h;r>1;r=h){h=r/2;if(z=r-h-h)break;}
   # single equals is not an error in the above line!
 if(!z){
   scale=os
   if(t)return or(x,y)
   return and(x,y)
 }

 if((x<0&&y>=0)||(y<0&&x>=0)){
   print "genstripe: sign mismatch\n"
   # Any return value here would be related to
   # a divergent sum with 'impossible' non-integral value
   scale=os;return 0;
 }
 if(x<0){
   z=6;while(z<repeat  )z+=z;repeat  =z-1-repeat
   z=6;while(z<override)z+=z;override=z-1-override
   scale=os
   return -1-genstripe(override,repeat,-1-x,-1-y)
   # not(genstripe(inv@(override),inv@(repeat),not(x),not(y)))
 }
 o=override;r=repeat
 z=0;t=1;while(x||y){
  h=r/2;b=r-h-h;r=h;if(r==1)r=repeat
  if(o){h=o/2;b=o-h-h;o=h}
  hx=x/2;hy=y/2
  if((x-hx-hx!=b&&y-hy-hy!=b)!=b)z+=t
  t+=t;b=!b;x=hx;y=hy
 }
 scale=os;return (z)
}  

## 'Multiplication'

# NB: none of these are equivalent to nim multiplication

# Perform STRIPED-OR 'multiplication' of x and y
define striped_orm(x,y){
  auto os,s,z,h;
  os=scale;scale=0
  x/=1;y/=1;s=1;if(x<0){x=-x;s=-s};if(y<0){y=-y;s=-s}
  z=0;while(y){h=y/2;if(y-h-h)z=stripe_(1,z,x);x+=x;y=h}
  scale=os;return s*z
}

# Perform STRIPED-AND 'multiplication' of x and y
define striped_andm(x,y){
  auto os,s,z,h;
  os=scale;scale=0
  x/=1;y/=1;s=1;if(x<0){x=-x;s=-s};if(y<0){y=-y;s=-s}
  z=0;while(y){h=y/2;if(y-h-h)z=stripe_(0,z,x);x+=x;y=h}
  scale=os;return s*z
}

# Perform generalised stripe 'multiplication' of x and y
define genstripem(override,repeat,x,y){
  auto os,s,z,h;
  os=scale;scale=0
  x/=1;y/=1;s=1;if(x<0){x=-x;s=-s};if(y<0){y=-y;s=-s}
  z=0;while(y){h=y/2;if(y-h-h)z=genstripe(override,repeat,z,x);x+=x;y=h}
  scale=os;return s*z
}

## Floating point

# Perform STRIPED-OR on binary floating point representations of x and y
define striped_orf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t
  z=stripe_(1,x,y)
  if(is_any_sfpr3_(x,y,z)){print "striped_orf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

# Perform STRIPED-AND on binary floating point representations of x and y
define striped_andf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t
  z=stripe_(0,x,y)
  if(is_any_sfpr3_(x,y,z)){print "striped_andf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

# Perform generalised stripe on binary floating point representations of x and y
define genstripef(o,r,x,y) {
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t
  z=genstripe(o,r,x,y)
  if(is_any_sfpr3_(x,y,z)){print "genstripef";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

## Floating point + 'Multiplication'

# Perform STRIPED-OR-M on binary floating point representations of x and y
define striped_ormf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t;t*=t
  z=striped_orm(x,y)
  if(is_any_sfpr3_(x,y,z)){print "striped_ormf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

# Perform STRIPED-AND-M on binary floating point representations of x and y
define striped_andmf(x,y){
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t;t*=t
  z=striped_andm(x,y)
  if(is_any_sfpr3_(x,y,z)){print "striped_andmf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

# Perform generalised stripe on binary floating point representations of x and y
define genstripemf(o,r,x,y) {
 auto os,t,z;
 os=scale;scale=0
  t=bw_mult_(os);x*=t;y*=t;t*=t
  z=genstripem(o,r,x,y)
  if(is_any_sfpr3_(x,y,z)){print "genstripemf";x+=sfpr_warn_msg_()}
 scale=os;return( z/t )
}

###from http://phodd.net/gnu-bc/code/logic_striping_meta.bc
### Logic_Striping_Meta.BC - Analysis of genstripe patterns
###  A library for exploring the mathematics of the striping pattern numbers used in logic_striping.bc which allows integers to be interpreted in a completely different way to either integer or modular arithmetic. See the end of the text documentation for more technical information. 
  ## To be used with Logic.BC and Logic_Striping.BC

## Pattern analysis

# negative pattern values represent flipped bits
# e.g. -1[xyz...] is equivalent to 1[(1-x)(1-y)(1-z)(1-...]
# this matches with the definition in rep_stripe_pattern where
# 'multiplying' by the integer -1 flips all bits.
# Technically this is 1s complement negation, meaning that two zeros would
# exist, but in fact an infinite number of zeros exist in the positive-only
# patterns: 10, 100, 1000 and these are each stated to be equivalent to their
# bit flipped counterparts, so this is not a concern.

# Reduces a pattern to the smallest number that will represent it
# . Patterns take binary form 1[pattern to repeat]
# . e.g. 101 => ...0101010101; 11001 => ...1001100110011001
# . some patterns are equivalent;
# . . e.g. 10101 will create the same pattern as 101
# . Given 21 decimal therefore (10101 binary)
# . . this function will return 5 (101 binary)
define simplify_stripe_pattern(x) {
  auto os,w,wh,wp,dp,d,r,m,s
  os=scale;scale=0;x/=1
  s=0;if(x<0){s=1;x=-x}
  if(x==0||x==1){if(s)x=1-x;scale=os;return x}
  if(x==2||x==3){if(s)x=5-x;scale=os;return x}
  w = bitwidth(x)-1
  wh = w/2;if(wh==0)wh=1
  wp = 2^w
  n = x-wp # trim high/lead bit
  if(s)n = wp-1-n # flip bits for negative
  for(dp=d=1;d<=wh;d++){
    dp+=dp;r=w/d
    if(w==r*d){
      m=(n*dp)/wp # check if this is a minimal bit pattern to spread
      #to make the above the same width as wp-1
      #we need to repeat it r times
      #so that's m*(dp^r-1)/(dp-1)
      if( n*(dp-1) == m*(dp^r-1) ){n = m; break}
    }
  }
  if(d>wh)d=w
  scale=os;return n+2^d
}

# Pattern equivalent of raising to a power or multiplying by integer
define rep_stripe_pattern(x,p) {
  auto d,os,s;
  os=scale;scale=0;x/=1;p/=1
  s=0;if(p<0){p=-p;s=!s}
  if(x<0){x=-x;s=!s}
  if(x==0||x==1){scale=os;return x}
  if(p==0){scale=os;return 1}
  if(p==1&&!s){scale=os;return x}
  d = 2^(bitwidth(x)-1)
  if(s){
    x=3*d-1-x
    if(p==1){scale=os;return x}
  } # negative power flips bits
  p = d^p
  x = (x-d)*(p-1)/(d-1)+p
  scale=os;return x
}

# Given pattern x, find its length with respect to its simplest form
define repsof_stripe_pattern(x) {
  auto os,w,wh,wp,dp,d,r,m;
  os=scale;scale=0;x/=1
  if(x<0)x=-x # sign doesn't matter here
  if(x==0||x==1){scale=os;return 0}
  w = bitwidth(x)-1
  wh = w/2;if(wh==0)wh=1
  wp = 2^w
  n = x-wp # trim high/lead bit
  for(dp=d=1;d<=wh;d++){
    dp+=dp;r=w/d
    if(w==r*d){
      m=(n*dp)/wp # check if this is a minimal bit pattern to spread
      if( n*(dp-1) == m*(dp^r-1) ){d=0;break}
    }
  }
  if(d)r=1 # no minimal found. prime pattern
  scale=os;return r
}

# Produce the next matching stripe pattern in a family
# e.g. 1[011] -> 1[011][011]; 1[10][10] -> 1[10][10][10]
define next_match_stripe_pattern(x) {
  auto os,w,wh,wp,dp,d,r,m,s
  os=scale;scale=0;x/=1
  s=0;if(x<0){s=1;x=-x}
  if(x==0||x==1){scale=os;return x}
  os=scale;scale=0
  w = bitwidth(x)-1
  wh = w/2;if(wh==0)wh=1
  wp = 2^w
  n = x-wp # trim high/lead bit
  if(s)n = wp-1-n # flip bits for negative
  for(dp=d=1;d<=wh;d++){
    dp+=dp;r=w/d
    if(w==r*d){
      m=(n*dp)/wp # check if this is a minimal bit pattern to spread
      if( n*(dp-1) == m*(dp^r-1) ){d=0;break}
    }
  }
  if(d){r=1;dp=wp;m=n}
  wp=dp^(r+1)
  n=wp+(m*(wp-1))/(dp-1)
  scale=os;return n
}

## Convert stripe patterns to and from alternative formats

# Convert stripe pattern of form 1[xyz...] to 2's complement format of
# . [xyz...] if x == 1;
# . not([(1-x)(1-y)(1-z)(1-...]) if x == 0
define stripe_pattern_to_2c(x) {
  auto os,w,s,n,wp;
  os=scale;scale=0;x/=1
  s=0;if(x<0){s=1;x=-x}
  if(x==0||x==1){scale=os;return x-1}
  w=bitwidth(x);wp=2^(w-1);n=x-wp#drop lead bit
  if(s)n=wp-1-n#flip bits if x was negative
  if(n<2^(w-2))n-=wp
  scale=os;return n
}

# Convert stripe pattern of form 1[xyz...] to 1's complement format of
# . [xyz...] for x == 1
# . -[(1-x)(1-y)(1-z)(1-...] if x == 0;
define stripe_pattern_to_1c(x) {
  x = stripe_pattern_to_2c(x);
  if(x<0).=x++
  return x
}

# Inverse of the above
define stripe_pattern_from_1c(x) {
  auto os,w;
  os=scale;scale=0;x/=1
  w=bitwidth(x)
  if(x>0){scale=os;return x+2^w}
  scale=os;return 2^(w+1)+x-1
}  

# Inverse of ..._to_2c
define stripe_pattern_from_2c(x) {
  if(x<=0).=x++
  return stripe_pattern_from_1c(x)
}

### Advanced Pattern Combination.
### . Multiplication-like methods, Division-like inverses to multiplication
### . Addition / Catenation, Subtraction / Decatenation

## 'Standard' multiplication / division / square root

# Pattern multiplication; Largely asymmetrical
# . Repeats the pattern of the left hand parameter either as-is
# . or bit flipped depending on the bits in the pattern of the
# . right hand parameter.
# . e.g. 1[pattern] x 1[0110] =
# . . 1[0=>flipped pattern][1=>pattern][1=>pattern][0=>flipped pattern]
# . e.g. 1[1101] x 1[0110] = 1[0010][1101][1101][0010]
# . Note that this is asymmetrical. With params swapped:
# . e.g. 1[0110] x 1[1101] = 1[0110][0110][1001][0110]
# ..........
# . Powers of two in the right parameter correspond to negative integers in
# . the right parameter in rep_stripe_pattern(), whereas one less than a power
# . of two corresponds to a positive integer in the same place.
# . This suggests that patterns may be a strange class of sub-integer or
# . perhaps some relative of surreal numbers.
# . They are somewhere between bijective unary and binary!
# . i.e rep...(x,p[+ve]) <==> mul...(x,2^(p+1)-1)
# . and rep...(x,p[-ve]) <==> mul...(x,2^(-p))
# . so p = 3 --> 2^(3+1)-1 = 15 decimal = 1111 binary pattern
# . what number would binary pattern 1101 translate back to?
# . This multiplication method preserves integers represented in the above way
# . and is symmetric for these, suggesting that there is something curious
# . about the other patterns.
define mul_stripe_patterns(x,y) {
  auto os,z,bx,by,qx,qz,p[],i,hy;
  os=scale;scale=0;x/=1;y/=1
  if(x==0||y==0){scale=os;return 0}
  if(x==-1||x==1||y==-1||y==1){scale=os;return 1}
  qx = 2^(bx = bitwidth(x)-1)
          by = bitwidth(y)-1
  if(x<0)x=3* qx   +x-1 # Flip bits of -ve params
  if(y<0)y=3*(2^by)+y-1
  if(x==3){scale=os;return y} # pattern 3 == 1[1] is multiplicative identity!
  if(y==3){scale=os;return x} # in either param. works even though asymmetric
  qz = 2^(bx*by)              # n.b. pattern 2 == 1[0] works as negative m.i.
  p[1] = x-qx                 # in either param. too.
  p[0] = qx+qx-1-x
  z=0;for(i=1;i<qz;i*=qx){hy=y/2;z+=i*p[y-hy-hy];y=hy}
  z+=qz
  scale=os;return z
}

# Attempt to solve z = mul...(x,y) for x
define div1_stripe_patterns(z,y){
  auto os,x,bz,by,bx,qz,qy,qx,t,p[],hy;
  os=scale;scale=0;z/=1;y/=1
  if(z==0||y==0){scale=os;return 0}
  if(z==1||z==-1){scale=os;return 1} # 1[] is zero pattern and 0/y = 0 so 1[]/y
  if(y==1||y==-1){
    print "div1_stripe_patterns: division by null pattern\n"
    scale=os;return 0
  }
  bz=bitwidth(z)-1
  by=bitwidth(y)-1
  # Check if bz is divisible by 'by'
    # Return an error if not
  bx=bz/by
  if(bx*by!=bz){
    print "div1_stripe_patterns: parameters of incompatible sizes\n"
    scale=os;return 0
  }
  qz=(qy=2^by)*(qx=2^bx)
  if(z<0)z=3* qz +z-1 # Flip bits of -ve params
  if(y<0)y=3* qy +y-1
  if(y==3){scale=os;return z} # pattern 3 == 1[1] is multiplicative identity
  if(y==2){scale=os;return qx+qz-z-1} # -ve multiplicative identity
  t=z/qx;x=z-qx*t;z=t # extract bits from RHS of z, and assume these are x
  hy=y/2;if(y-hy-hy){x=x;t=qx-1-x}else{t=x;x=qx-1-x}
  # ^ check last bit of y to see if we have obtained x or !x and swap accordingly
  y=hy;qy/=2
  p[0]=t # = bitflipped x
  p[1]=x
  while(qy>1){
    hy=y/2;t=z/qx
    if(p[y-hy-hy]!=z-t*qx) { # if last bits of z don't match what was found
      print "div1_stripe_patterns: parameters are incompatible\n"
      scale=os;return 0
    }
    qy/=2;y=hy;z=t
  }
  scale=os;return qx+x
}

# Attempt to solve z = mul...(x,y) for y
define div2_stripe_patterns(z,x){
  auto os,y,bz,bx,by,qz,qx,qy,nx,p2,fz,t;
  os=scale;scale=0;z/=1;x/=1
  if(z==0||x==0){scale=os;return 0}
  if(z==1||z==-1){scale=os;return 1} # 1[] is zero pattern and 0/y = 0 so 1[]/y = 1[]
  if(x==1||x==-1){
    print "div2_stripe_patterns: division by null pattern\n"
    scale=os;return 0
  }
  bz=bitwidth(z)-1
  bx=bitwidth(x)-1
  # Check if bz is divisible by 'bx'
    # Return an error if not
  by=bz/bx
  if(by*bx!=bz){
    print "div2_stripe_patterns: parameters of incompatible sizes\n"
    return 0
  }
  qz=(qx=2^bx)*(qy=2^by)
  if(z<0)z=3* qz +z-1 # Flip bits of -ve params
  if(x<0)y=3* qx +x-1
  x-=qx
  nx=qx-1-x
  y=0
  for(p2=1;z>1;p2+=p2){
    fz=z/qx
    t=z-fz*qx
    if(t==x){
      y+=p2
    } else if(t!=nx) {
      print "div2_stripe_patterns: parameters are incompatible\n"
      scale=os;return 0
    }
    z=fz
  }
  scale=os;return qy+y
}

# Attempt to solve z = mul...(x,x) for x
define sqrt_stripe_pattern(z){
  # Usual preamble
  auto os,y,bz,bx,qz,qx,hy,p[],t;
  os=scale;scale=0;z/=1
  if(z==0){scale=os;return 0}
  if(z==1||z==-1){scale=os;return 1} # 1[] is zero pattern and sqrt(0) = 0 so sqrt(1[]) = 1[]
  bz=bitwidth(z)-1
  # Check if bz is a square
    # Return an error if not
  bx=sqrt(bz)
  if(bx*bx!=bz){
    print "sqrt_stripe_pattern: parameter does not have square size\n"
    return 0
  }
  qz=(qx=2^bx);qz*=qx
  if(z<0)z=3* qz +z-1 # Flip bits of -ve param
  if(z==3){scale=os;return 3} # 3 => 1[1] is multiplicative id. and so sqrt(1[1]) = 1[1] => 3
  if(z+z<=3*qz){
    # square root of a "negative" pattern (one that starts 1[0...])
    print "sqrt_stripe_pattern: impossible square root\n"
    return 0
  }
  t=z/qx;x=z-qx*t;z=t # extract bits from RHS of z, and assume these are x
  y=x;hy=y/2 # set y to x and assign x and !x to associated bits of y
  p[t=y-hy-hy]=x
  p[!t]=qx-1-x
  y=hy
  while(z>1){
    hy=y/2;t=z/qx
    if(p[y-hy-hy]!=z-t*qx){
      print "sqrt_stripe_pattern: parameter has no square root\n"
      return 0
    }
    z=t;y=hy
  }
  # since square root has two possible values (1[pattern] and 1[!pattern])
  # set x to the 'positive' / larger of the two options
  x=p[0];if(x<p[1])x=p[1]
  scale=os;return qx+x
}

## NXOR and modular arithmetic multiplication-like pattern combination

# Mix stripe patterns so that the new length is the LCM of the old lengths
# . patterns extended to the right length and the bits are NXORed
# Is symmetric with respect to x and y, i.e. mix...(x,y) = mix...(y,x)
define mix_stripe_patterns(x,y) {
  auto os,bx,by,qx,r,gcd,t
  os=scale;scale=0;x/=1;y/=1
  if(x==0||y==0){scale=os;return 0}
  if(x==1||x==-1||y==-1||y==1){scale=os;return 1}
  qx = 2^(bx = bitwidth(x)-1)
          by = bitwidth(y)-1
  if(x<0)x=3* qx   +x-1 # Flip bits of -ve params
  if(y<0)y=3*(2^by)+y-1
  if(bx!=by){
    gcd=bx
    for(t=by;t>0;t=r){r=gcd%t;gcd=t}
    x=rep_stripe_pattern(x,  by/gcd)
    y=rep_stripe_pattern(y,t=bx/gcd)
    bx=by*=t # = bz
    qx=2^bx
  }
  x=xor(x,y) # bits flip incorrectly and q' bit is lost
  x=qx+qx-1-x # correct the above
  scale=os;return x
}

# Inverse of the above; Given a mixed pattern and one of the constituents
# . derive the other constituent (up to repeat-equivalence)
# . See notes elsewhere how patterns can be equivalent to each other
# . in some uses. This is one.
define unmix_stripe_patterns(z,x) {
  auto os,bz,bx,by,qz;
  os=scale;scale=0;z/=1;x/=1
  if(z==0||x==0){scale=os;return 0}
  if(z==1||z==-1){scale=os;return 1} # 1[] is zero pattern; 0/x=0
  if(x==1||x==-1){
    print "unmix_stripe_patterns: can't unmix null pattern\n"
    scale=os;return 0
  }
  bz=bitwidth(z)-1
  bx=bitwidth(x)-1
  # Check if bz is divisible by 'bx'
    # Return an error if not
  by=bz/bx
  if(by*bx!=bz){
    print "unmix_stripe_patterns: parameters of incompatible sizes\n"
    return 0
  }
  qz=2^bz
  if(z<0)z=3* qz    +z-1 # Flip bits of -ve params
  #if(x<0)y=3*(2^bx) +x-1# << handled by rep...() below
  x = rep_stripe_pattern(x,by) # increase x to length of z
  z = 3*qz-1-z # flip bits of z
  x = xor(x,z) # nXor (self-inverse) of repeated x and z
  x += qz # put back missing q' bit;
  x = simplify_stripe_pattern(x)
  scale=os;return x
}

# Modular sum of patterns so that the new length is the LCM of the old lengths
# . patterns extended to the same length and then modular arithmetic is done
# Is symmetric with respect to x and y, i.e. mix...(x,y) = mix...(y,x)
define modsum_stripe_patterns(x,y) {
  auto os,bx,by,qx,r,gcd,t
  os=scale;scale=0;x/=1;y/=1
  if(x==0||y==0){scale=os;return 0}
  if(x==1||x==-1||y==-1||y==1){scale=os;return 1}
  qx = 2^(bx = bitwidth(x)-1)
          by = bitwidth(y)-1
  if(x<0)x=3* qx   +x-1 # Flip bits of -ve params
  if(y<0)y=3*(2^by)+y-1
  if(bx!=by){
    gcd=bx
    for(t=by;t>0;t=r){r=gcd%t;gcd=t}
    x=rep_stripe_pattern(x,  by/gcd)
    y=rep_stripe_pattern(y,t=bx/gcd)
    bx=by*=t # = bz
    qx=2^bx
  }
  x=x-qx+y-qx # add together modulo qx
  if(x<qx)x+=qx # put back any missing q' bit
  scale=os;return x
}

# Inverse of the above; Given a modular sum of patterns and one of the
# . constituents, derive the other constituent (up to repeat-equivalence)
# . See notes elsewhere how patterns can be equivalent to each other
# . in some uses. This is one.
define unmodsum_stripe_patterns(z,x) {
  auto os,bz,bx,by,qz;
  os=scale;scale=0;z/=1;x/=1
  if(z==0||x==0){scale=os;return 0}
  if(z==1||z==-1){scale=os;return 1} # 1[] is zero pattern; 0/x=0
  if(x==1||x==-1){
    print "unmodsum_stripe_patterns: can't extract null pattern\n"
    scale=os;return 0
  }
  bz=bitwidth(z)-1
  bx=bitwidth(x)-1
  # Check if bz is divisible by 'bx'
    # Return an error if not
  by=bz/bx
  if(by*bx!=bz){
    print "unmodsum_stripe_patterns: parameters of incompatible sizes\n"
    return 0
  }
  qz=2^bz
  if(z<0)z=3* qz    +z-1 # Flip bits of -ve params
  #if(x<0)y=3*(2^bx) +x-1# << handled by rep...() below
  x = rep_stripe_pattern(x,by) # increase x to length of z
  if(z<x)z+=qz
  x=qz+z-x
  x = simplify_stripe_pattern(x)
  scale=os;return x
}

## Addition / Subtraction :: Catenation / Decatenation

# Pattern catenation; Asymmetrical
# . 1[x] + 1[y] = 1[x][y]
define cat_stripe_patterns(x,y) {
  auto os,qy;
  os=scale;scale=0;x/=1;y/=1
  if(x==0||y==0){scale=os;return 0}
  qy = 2^(bitwidth(y)-1)
  if(x<0)x=3*2^(bitwidth(x)-1)+x-1 # Flip bits of -ve params
  if(y<0)y=3*       qy        +y-1
  if(x==1){scale=os;return y} # pattern 1 == 1[] is catenate identity!
  if(y==1){scale=os;return x} # in either param. works even though asymmetric
  .=x--
  scale=os;return x*qy+y
}

# Pattern decatenation; Like subtraction but not
# . 1[z]-1[y]=1[x] if [z] is of form [x][y], else 1[z]-1[y]=1[z]+1[!y]=1[z][!y]
define decat_stripe_patterns(z,y) {
  auto os,x,bz,by,qy;
  os=scale;scale=0;z/=1;y/=1
  if(z==0||y==0){scale=os;return 0}
          bz = bitwidth(z)-1
  qy = 2^(by = bitwidth(y)-1)
  if(z<0)z=3* 2^bz +z-1 # Flip bits of -ve params
  if(y<0)y=3* qy   +y-1
  if(z==y){scale=os;return 1} # pattern - self = 1[] (catenate identity)
  if(y==1){scale=os;return z} # pattern - 1[]  = self
  if(bz<by){
    # if left pattern is shorter than right pattern
    # no subtraction can occur so 1[z]-1[y] -> 1[z]+1[!y]
    y = 3*qy-y-1 # (re)flip bits
    .=z--
    scale=os;return z*qy+y
  }
  # Check if last bits of z are equal to y
  x = z/qy
  if(z-x*qy==y-qy){scale=os;return x}
  # Guess not
  y = 3*qy-y-1 # (re)flip bits
  .=z--
  scale=os;return z*qy+y
}

# Overlap cancelling decatenation
# . 1[z]-1[y] = 1[a][b]-1[b][c] = 1[a][!c] = 1[x]
# . any of a, b or c may be empty
# . and b is of maximal size
define decat2_stripe_patterns(z,y) {
  auto os,x,qy,qc,b;
  os=scale;scale=0;z/=1;y/=1
  if(z==0||y==0){scale=os;return 0}
  qz = 2^(bitwidth(z)-1)
  qy = 2^(bitwidth(y)-1)
  if(z<0)z=3* qz +z-1 # Flip bits of -ve params
  if(y<0)y=3* qy +y-1
  if(z==y){scale=os;return 1} # pattern - self = 1[] (catenate identity)
  if(y==1){scale=os;return z} # pattern - 1[]  = self
  b = y-(qb=qy); qc = 1 # b will contain overlap bits
  if(qz<qy){qc=qy/qz;b/=qc;qb/=qc}
    # if z is shorter than y, truncate b to length of z;
    # there cannot be a longer match
  for(qc=qc;qb;qc+=qc){x=z/qb;if(z-x*qb==b)break;b/=2;qb/=2}
  #qc-1-y%qc        # RHS of result: flipped RH bits of y that did not match [!c]
  #z/(qb/qc) = x*qc # LHS of result: z with matching LH bits from y removed [a]
  .=x++;x=x*qc-y%qc;.=x-- # x=x*qc+qc-1-y%qc
  scale=os;return x
}

# Largest total mismatch cancelling pattern catenation
# . 1[z]+1[y] = 1[a][b]+1[!b][c] = 1[a][c] = 1[x]
# . If z ends with a group of bits of opposite parity to a group of
# . bits at the start of y, then these bits ([b] and [!b]) are erased.
# . The remaining bits are then catenated.
# . This form of catenation has the advantage of preserving addition
# . for the integers as represented by powers of two and
# . one less than powers of two.
# . e.g. (-3) + 2 -> 1000 + 111 -> 1[0][00] + 1[11][] = 1[0][] = 10 -> -1
# . The standard catenation would have returned 1[000][111] = 1000111 -> ???
define undecat2_stripe_patterns(z,y) {
  return decat2_stripe_patterns(z,-y)
}


###from http://phodd.net/gnu-bc/code/melancholy.bc
### Melancholy.BC - A collatz-like iteration leading to zero, or loops.
### Twin suites of functions for investigating the two kinds of Melancholy Numbers and the iterations which lead to them. These are a discovery undoubtedly made by many people, myself included.
### Your humble author is guilty of coining the term "melancholy" with the intention of comparing these with the unhappy numbers. See here for a Usenet discussion on the first and original kind, and also many notes stored within the bc code in both files.
max_array_ = 4^8-1

# Much like the Collatz conjecture, the conjecture here is that numbers x,
# under the iteration x -> floor(sqrt(x))*(x-floor(sqrt(x))^2)
# will eventually reach zero (or equivalently x reaches a perfect square,
# since the following step is necessarily zero), OR the iteration enters
# a loop (the simplest example being 8 -> 2*(8-2^2) = 8 again).

# It is unproven whether there is some number or numbers for which the
# iteration increases to infinity, never looping nor reaching zero.
# Theoretically this is possible, since the iteration will, half the time,
# generate a number larger than x. [When x is one less than a perfect square,
# the generated number is 2*floor(sqrt(x))^2, or equivalently, 2*(x^2-2*x+1)]
# Probabilistically however, the average generated value is floor(sqrt(n))^2,
# which is a perfect square and also less than x (thus heading towards zero)
# and there are many cases where a perfect square is generated "unexpectedly",
# (due to a non-squarefree number being created by the subtraction,)
# both increasing the chance that the following step will be zero.

# In a parallel with Happy/Sad numbers, I have named those numbers which
# DO NOT reach zero, Melancholy numbers. Of the numbers <= 2500000,
# approximately 5% of these are melancholy. Of melancholy numbers, around
# two-thirds of these become trapped in the aforementioned 8 -> 8 cycle.

## Notes and example uses

# scale=0;for(i=0;i<65536;i++)root[i]=count[i]=0;rci=0;"*";for(i=0;i<10^20;i++){n
# =melancholy_root(i);f=-1;for(j=0;j<=rci;j++)if(root[j]==n){f=j;break};if(f==-1)
# {rci+=1;root[rci]=n;count[rci]=1}else{count[f]+=1};if(i%10000==0){print "@",i,"
# \n";for(j=0;j<=rci;j++)print root[j],": ",count[j],"\n";print"\n"}}

#@2500000
#0: 2371650
#8: 83591
#1927: 39499
#18469: 3268
#46208: 1639
#39852: 328
#1816705: 26

# c=0;m=0;for(i=0;i<1000000;i++){om=m;m=is_melancholy(i);if(om&&m){if(c==0)f=i-1;
# c+=1}else if(c){for(j=0;j<=c;j++)print f+j," ";print"\n";c=0}}

# 43823 43824 43825 43826 are a chain of four consecutive melancholy numbers
# 184894 184895 184896 184897 ditto
# 330397 330398 330399 330400 ditto
# 380168 380169 380170 380171 ditto
# 502477 502478 502479 502480 ditto
# 658871 658872 658873 658874 ditto
# 673771 673772 673773 673774 ditto
# 876977 876978 876979 876980 ditto

# max=0;for(i=0;i<1000000;i++)if(m=melancholy_chainlength(i)>max){max=m;i}
# 1
# 2
# 3
# 10
# 22
# 33
# 46
# 58
# 75
# 158
# 185
# 393
# 673
# 771
# 834
# 835
# 1019
# 1223
# 2586
# 2699
# 5137
# 11428
# 11581
# 27753
# 53307
# 65516
# 86406
# 125833
# 148916
# 175463
# 189804
# 274509
# 491106
# 584753
# 681782
# 823866
# 881217

# Determine if x is one of the 5% of numbers that are melancholy
define is_melancholy(x) {
  auto os,n,i,tape[],tapetop;
  os=scale;scale=0
  x/=1
  if(x<0)return 1;
  if(x==0){scale=os;return 0}
  tapetop=-1;
  while(1){
    n=sqrt(x);x=n*(x-n*n)
    if(x==0){scale=os;return 0}
    # Search backwards for previous occurrence of x (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==x){scale=os;return 1}
    if(tapetop++>max_array_){
      print "is_melancholy: can't calculate ...; chain too long\n"
      scale=os;return 1
    }
    tape[tapetop]=x
  }
}

# Print the chain of iterations of x until a loop or zero
define melancholy_print(x) {
  auto os,n,i,tape[],tapetop;
  os=scale;scale=0
  x/=1
  if(x<0)return 1;
  if(x==0){scale=os;return x}
  tapetop=-1;
  while(1){
    n=sqrt(x);x=n*(x-n*n)
    if(x==0){scale=os;return x}
    # Search backwards for previous occurrence of x (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==x){scale=os;"looping ";return x}
    if(tapetop++>max_array_){
      print "melancholy_print: can't calculate ...; chain too long\n"
      scale=os;return 1
    }
    tape[tapetop]=x;x
  }
}

# Return 0 for non-melancholy numbers or the smallest number in the loop
# that the iteration becomes trapped within.
define melancholy_root(x) {
  auto os,n,i,tape[],tapetop;
  os=scale;scale=0
  x/=1
  if(x<0)return 1;
  if(x==0){scale=os;return 0}
  tapetop=-1;
  while(1){
    n=sqrt(x);x=n*(x-n*n)
    if(x==0){scale=os;return 0}
    # Search backwards for previous occurrence of x (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==x){
      #go back the other way looking for the lowest value
      while(++i<=tapetop)if(tape[i]<x)x=tape[i]
      scale=os;return x
    }
    if(tapetop++>max_array_){
      print "melancholy_root: can't calculate ...; chain too long\n"
      scale=os;return -1 # Error: Unknown
    }
    tape[tapetop]=x
  }
}

# Find the maximum 'hailstone' i.e. the largest number in the chain of
# iterations from x to loop or zero.
define melancholy_max(x) {
  auto os,n,i,max,tape[],tapetop;
  os=scale;scale=0
  x/=1
  if(x<0)return 1;
  if(x==0){scale=os;return 0}
  tapetop=-1;max=x
  while(1){
    n=sqrt(x);x=n*(x-n*n)
    if(x>max)max=x
    if(x==0){scale=os;return max}
    # Search backwards for previous occurrence of x (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==x){scale=os;return max}
    if(tapetop++>max_array_){
      print "melancholy_max: can't calculate ...; chain too long\n"
      scale=os;return max
    }
    tape[tapetop]=x
  }
}

# For melancholy numbers, returns the size of the loop the iterations
# become trapped within. e.g. 8 -> 8 is a loop of 1
define melancholy_loopsize(x) {
  auto os,n,i,tape[],tapetop;
  os=scale;scale=0
  x/=1
  if(x<0)return 1;
  if(x==0){scale=os;return 0}
  tapetop=-1;
  while(1){
    n=sqrt(x);x=n*(x-n*n)
    if(x==0){scale=os;return 0}
    # Search backwards for previous occurrence of x (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==x){ scale=os;return tapetop-i+1 }
    if(tapetop++>max_array_){
      print "melancholy_loopsize: can't calculate ...; chain too long\n"
      scale=os;return -1 # Error: Unknown
    }
    tape[tapetop]=x
  }
}

# Find how many iterations are required to find a repeated iteration (loop)
# or zero
define melancholy_chainlength(x) {
  auto os,n,i,c,tape[],tapetop;
  os=scale;scale=0
  x/=1
  if(x<0)return 1;
  if(x==0){scale=os;return 0}
  tapetop=-1;
  while(1){
    .=c++
    n=sqrt(x);x=n*(x-n*n)
    if(x==0){scale=os;return c}
    # Search backwards for previous occurrence of x (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==x){ scale=os;return 2-c }# infinity
    if(tapetop++>max_array_){
      print "melancholy_chainlength: can't calculate ...; chain too long\n"
      scale=os;return -c
    }
    tape[tapetop]=x
  }
}

# Perhaps a misnomer. This returns the square root of the perfect square
# which dropped the iteration to zero on the following step
# Returns -1 in the case of a melancholy number since the iteration loops
# and there is no 'last' term.
define melancholy_lastsqrt(x) {
  auto os,n,i,tape[],tapetop;
  os=scale;scale=0
  x/=1
  if(x<0)return 1;
  if(x==0){scale=os;return 0}
  tapetop=-1;
  while(1){
    n=sqrt(x);x=n*(x-n*n)
    if(x==0){scale=os;return n}
    # Search backwards for previous occurrence of x (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==x){ scale=os;return -1 }# there isn't one
    if(tapetop++>max_array_){
      print "melancholy_lastsqrt: can't calculate ...; chain too long\n"
      scale=os;return -1 # Error: Unknown
    }
    tape[tapetop]=x
  }
}

# All of the above rolled into one. Negative values suggest error condition.
# Global variables are set with the same names as the above functions
# with the exception of global variable melancholy_print, which should be
# set to non-zero if emulation of the melancholy_print() function is required
define is_melancholy_sg(x) {
  auto os,n,i,max,c,tape[],tapetop;
  os=scale;scale=0
  x/=1
  if(x<0)return 1;
  if(x==0){
    melancholy_root        = 0
    melancholy_max         = 0
    melancholy_loopsize    = 0
    melancholy_chainlength = 0
    melancholy_lastsqrt    = 0
    scale=os;return 0
  }
  tapetop=-1;
  while(1){
    .=c++
    n=sqrt(x);x=n*(x-n*n);if(melancholy_print)x
    if(x>max)max=x
    if(x==0){
      melancholy_root        = 0
      melancholy_max         = max
      melancholy_loopsize    = 0
      melancholy_chainlength = c
      melancholy_lastsqrt    = n
      scale=os;return 0 # is not melancholy
    }
    # Search backwards for previous occurrence of x (which is more
    #   likely to be near end of tape since chains lead to loops)
    for(i=tapetop;i>0;i--)if(tape[i]==x){
      melancholy_max         = max
      melancholy_loopsize    = tapetop-i+1
      melancholy_chainlength = 2-c # Infinite
      melancholy_lastsqrt    = -1 # Error: Unknown
      #go back the other way looking for the lowest value
      while(++i<=tapetop)if(tape[i]<x)x=tape[i]
      melancholy_root        = x
      scale=os;return 1 # is melancholy
    }
    if(tapetop++>max_array_){
      print "is_melancholy_sg: can't calculate ...; chain too long\n"
      melancholy_root        = -1 # Error: Unknown
      melancholy_max         = -max
      melancholy_loopsize    = -1 # Error: Unknown
      melancholy_chainlength = -c
      melancholy_lastsqrt    = -n
      scale=os;return 1 # is melancholy
    }
    tape[tapetop]=x
  }
}

###from http://phodd.net/gnu-bc/code/misc_235.bc

## Find the nearest sum of powers of 2, 3, and 5 to make a number

define print235(x) {
 auto max5,lx,ni,nj,n,found,diff,near,sn,si,sj,sk;
 max5 = l(x)/l(5)+1
 found = 0
 near = x;
 for(i=0;i<=max5;i++){
  ni=5^i
  nj=ni
  for(j=0;x>nj;j++){
   nj=ni+3^j
   n=nj
   for(k=0;x>n;k++){
    n = nj+2^k;#print "n: ",0*n,", i: ",i,", j: ",j,", k: ",k,"\n";
    diff = x-n;if(diff<0)diff=-diff
    if(diff<near){near=diff;sn=n;si=i;sj=j;sk=k}
    if(x==n){found=1;print x," == 2^",k," + 3^",j," + 5^",i,"\n"}
   }#end for k
  }#end for j
 }#end for i
 if(!found){
  print "nearest found: ",sn
  print " == 2^",sk
  print  " + 3^",sj
  print  " + 5^",si
  print "\n"
 }
 return( found );
}

###from http://phodd.net/gnu-bc/code/misc_anglepow.bc
### AnglePow.BC - exponentional functions that are semi-linear,
#   changing gradient at each power of the base.
### A semi linear version of exponentiation and logarithm related to the number sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, etc. [See the OEIS's A037124] 
# run with funcs.bc

## Specific functions for base 10

# Generate the x-th number in the sequence:
# 1,2,3,4,5,6,7,8,9,10,20,30,...,90,100,200,300,...,900,1000,2000,...
# e.g. anglepow10(0) = 1 ; anglepow10(11) = 30
define anglepow10(x) {
  return( (remainder(x,9)+1) * A^int(x/9) )
}

# Invert the above
# e.g. anglelog10(50) = 13 ; ial10(1) = 0
define anglelog10(x) {
  auto k;
  k = int_log(A,x)
  return( 9*k + x/A^k - 1 )
}

## Generalised functions for any base b

# anglepow(10,x) is equivalent to the above anglepow10(x)
define anglepow(b,x) {
  return( (remainder(x,b-1)+1) * b^int(x/(b-1)) )
}

# Invert the previous function
define anglelog(b,x) {
  auto k
  k = int_log(b,x)
  return( (b-1)*k + x/b^k - 1)
}

###from http://phodd.net/gnu-bc/code/misc_perfectpow.bc

## Find the nearest perfect power to a number
## (picks the lower number in the case of a tie)
## e.g. 26 -> 25 = 5^2 and not 27 = 3^3
##      26.01 -> 27 however because it is closer.

#scale=10;sy=0;x=7;x;min=x;for(p=2;int(root(x,p-1))>1;p++){n=int(root(x,p))-1;fo
#r(m=0;m<2;m++){n+=1;y=n^p;y;diff=abs(x-y);if(diff<min){min=diff;sy=y}}};sy

# Uses array pass by reference to fill the given array
# with [0] the perfect power
#      [1] the number which is raised
#      [2] the power itself
#      [3] the sign of the original parameter
# e.g. -124 -> {125,5,3,-1} and returns -125
define nearest_perfect_power_a(*a__[],x){
  auto os,s,min,p,n,m,y,diff;
  s=1;if(x<0){s=-1;x=-x}
  if(x+x<5){
    a__[0]=a__[1]=!!x;a__[2]=2;a__[3]=s
    return s*a__[0]
  }
  os=scale;scale=20
  min=n=x
  for(p=2;n>2;p++){
    n=int(root(x,p))-1
    for(m=0;m<2;m++)if((diff=abs(x-(y=(++n)^p)))<min){
      a__[0]=y;a__[1]=n;a__[2]=p;
      if(!min=diff){n=0;break}
    }
  }
  a__[3]=s
  scale=os;return s*a__[0];
}

define nearest_perfect_power(x){
  auto dummy[];
  return nearest_perfect_power_a(dummy[],x)
}

###from http://phodd.net/gnu-bc/code/misc_srr.bc
###The Sum of Repeated Roots function
###The mathematical formula for this interesting function is: 	
###        ∞
###SRR(x) =Σ   x2^-n - 1
###      n = 1
###  Or as simply as possible: srr(x) = sum[n=1..oo] x^(2^(-n))-1 
define srr(x) {
  auto s,t,os;
  if(x<=0){print "srr: Negative Infinity\n";return 1-A^scale}
  scale+=6
  s=x ; os=s+1
  t=0;while(os!=s){
    os=s
    s=sqrt(s)
    t+=s-1
  }
  scale-=6;t/=1
  return(t);
}

define srr_n(n,x) { # Generalisation of srr; srr(x) == srr_n(2,x)
  auto s,t,os;
  if(x<=0){print "srr_n: Negative Infinity\n";return 1-A^scale}
  if(n==2)return(srr(x))
  if(n<=1){print "srr_n: Infinity\n";return A^scale-1}
  scale+=6
  s=x ; os=s+1
  t=0;while(os!=s){
    os=s
    s=e(l(s)/n)
    t+=s-1
  }
  scale-=6;t/=1
  return(t);
}

###from http://phodd.net/gnu-bc/code/orialc.bc
### OrialC.BC - Variants of primorial and lcmultorial
###             Some extended to be continuous over the positive reals

## N.B. extensions to the reals are not to be considered to be 'correct'
## in any sense other than the values returned for fractional values of
## the input are between the values returned for the preceding and
## succeeding integer input values and that there is some logic to the
## calculation chosen for that interpolation.

#### requires primes.bc, funcs.bc and factorial.bc

### Primorials

# Use a factorial substrate
# . Maps the gradient of the logarithm of the factorial function 
# . (taken here to be continuous, as a shifted Gamma function)
# . between two primes onto the space between the logarithm of their
# . primorials and then returning the antilogarithm of the result
define primorialc_fact(x) {
  auto p,q,pp,qq,xx
  if(x<0)return 1
  if(x<=3)return factorial(x)
  if(x==int(x)&&is_prime(x))return primorial(x)
  p=prevprime(x)
  q=nextprime(x)
  pp=primorial(p)
  qq=lnfactorial(q)/l(pp*q) #.../l(primorial(q))
  pp=lnfactorial(p)/l(pp)
  xx=(x-p)*(qq-pp)/(q-p)+pp
  return e(lnfactorial(x)/xx)
}

## Geometric variants

# Multiply by a fractional power of the next prime
# (equivalent to dividing by a fractional power of the previous prime)
# i.e. 6# = 5# * 7^(1/2); (5+1/3)# = 5# * 7^(1/6)
define primorialc_nextp(x) { # next prime
  auto p,q,pp,c
  if(x<0)return 1
  if(x<=3)return factorial(x)
  if(x==int(x)&&is_prime(x))return primorial(x)
  p=prevprime(x)
  q=nextprime(x)
  pp=primorial(p)
  c=(x-p)/(q-p)
  return pp*e(l(q)*c)
}

# Multiply by a fractional power of x, which tends to the next prime
# i.e. 6# = 5# * 6^(1/2); ; (5+1/3)# = 5# * (5+1/3)^(1/6)
define primorialc_self(x) { # power of self
  auto p,q,pp,c
  if(x<0)return 1
  if(x<=3)return factorial(x)
  if(x==int(x)&&is_prime(x))return primorial(x)
  p=prevprime(x)
  q=nextprime(x)
  pp=primorial(p)
  c=(x-p)/(q-p)
  return pp*e(l(x)*c)
}

# Backstepping
# as x moves from p to q, c moves from 0 to 1 and p*q/x moves backward(!) from q to p
# by taking the (1-c) power of p*q/x and dividing qq by it, we arrive at a value
# between pp and qq
define primorialc_backstep(x) {
  auto p,q,qq,c
  if(x<0)return 1
  if(x<=3)return factorial(x)
  if(x==int(x)&&is_prime(x))return primorial(x)
  p=prevprime(x)
  q=nextprime(x)
  qq=primorial(q)
  c=(x-p)/(q-p)
  return qq*e( (l(p)+l(q)-l(x)) *(c-1)) # qq/[p*q/x]^(1-c)
}

# as above but the logarithm of p*q/x has been miscalculated
# ... by chance this provides rational values for some non-prime x
# ... and is actually nearer the factorial substrate approximation
# 4 -> 15; 9 -> 770; 14 -> 63813.75; 25 -> 718854803+1/3
# 64 -> 982290193885033381984886.25
# 81 -> 29673835076586205706180446443643+1/3
# 144 -> 124348529244939943338239644717986755712298655277238710867.5
# 225 -> 5554080608320289669170856425325402549408978069390687643641198516538486176108852697155674
# 249 -> 21422110305969548290776878409368904436960062197203069371414919560299383455960234384175066914411473410
# 324 -> 356034387670665137061613427387632108186745506097843755843955808839176060801252605904504975998092127868894051024069337085229799569148+1/3
# 441 -> 5085683323024301173004199827150236333411871189788725295515084157086768337985718219869705458593441981460396117256011585703398191894858977077274060373508432687656189696902577543317890
define primorialc_accident(x) {
  auto p,q,qq,c
  if(x<0)return 1
  if(x<=3)return factorial(x)
  if(x==int(x)&&is_prime(x))return primorial(x)
  p=prevprime(x)
  q=nextprime(x)
  qq=primorial(q)
  c=(x-p)/(q-p)
  return qq*e(l(p+q-x)*(c-1)) # not qq/[p*q/x]^(1-c)
}

define primorialc(x) {
  print "Please use one of:\n"
  print "* primorialc_fact(",    x,")\n"
  print "* primorialc_nextp(",   x,")\n"
  print "* primorialc_self(",    x,")\n"
  print "* primorialc_backstep(",x,")\n"
  print "* primorialc_accident(",x,")\n"
  return primorial(int(x))
}

## Submodulus

# submodulus superprimorial/factorial
#  = product of x mod k for all 2 <= k < x
define submodorial(x) {
  # is zero for composite x, < factorial(x) and > primorial(x) for prime x
  auto os,i,p;
  os=scale;scale=0;x/=1;scale=os
  if(x==0||x==1)return 1
  if(x<0||!is_prime(x))return 0
  if(x<4)return 1
  scale= 0;p=1;for(i=2;i<x;i++)p*=x%i
  scale=os;return p
}

# generalised submodulus superprimorial / factorial
# = product of n+(x mod k) for all 2 <= k < x
# . equal to the above for n==0
# ? possibly only interesting for n==1
#   since submodprimorialg(1,x-1) == submodprimorial(x) for x prime
#   [for 1 <= k < x, multiply the result by n]
define submodorialg(n,x) {
  auto os,i,p;
  if(n==0)return submodprimorial(x)
  n/=1
  os=scale;scale=0;x/=1;if((p=n/1)==n)n=p
  p=1;for(i=2;i<x&&p;i++)p*=n+(x%i)
  scale=os;return p
}

### LCMultorials

# Multiply by a fractional power of the next step up
define lcmultorialc(x) {
  auto ix,l,m
  if(x<=1)return 1
  l=lcmultorial(ix=int(x))
  if(x==ix)return l;
  m=int_lcm(l,ix+1)
  if(m==l)return l;
  return l*e(l(m/l)*(x-ix))
}

# Subprimorial using LCM of terms rather than multiplying
define lcmsubprimorial(n) {
  auto i,pm,p;
  pm=1;p=2
  if(prime[max_array_])for(i=2;i<=max_array_&&p=prime[i]<=n;i++)pm=int_lcm(pm,p-1)
  for(.=.;p<=n;p=nextprime(p))pm=int_lcm(pm,p-1)
  return pm
}

# Submodulus product using lcm rather than multiplication
define lcmsubmodorial(x) {
  # is zero for composite x, < factorial(x) and > primorial(x) for prime x
  auto os,i,p;
  os=scale;scale=0;x/=1;scale=os
  if(x==0||x==1)return 1
  if(x<0||!is_prime(x))return 0
  if(x<4)return 1
  scale= 0;p=1;for(i=2;i<x;i++)p=int_lcm(p,x%i)
  scale=os;return p
}

# Generalisation of the above
define lcmsubmodorialg(n,x) {
  auto os,i,p;
  if(n==0)return lcmsubmodorial(x)
  n/=1
  os=scale;scale=0;x/=1;if((p=n/1)==n)n=p
  p=1;for(i=2;i<x&&p;i++)p=int_lcm(p,n+(x%i))
  scale=os;return p
}

###from http://phodd.net/gnu-bc/code/output_formatting.bc
### Output-Formatting.BC - Formatted output

 # Functions in this library with a name containing "print" return a result
 # equivalent to what has been output, meaning that to use them properly,
 # they must be assigned to a dummy variable to prevent bc from inadvertently
 # printing out the return value!

 # An example usage might be q=printfrac(0,5,0.25)+newline()
 #  q here is a dummy variable, printfrac will print 0.25 as a fraction and
 #  the newline function prints a carriage return. Net result should be:
 #   1/4

 # Literally and figuratively adding the newline() and printspc/tabs()
 # (q.v.) is recommended, as these neaten the output.

## Bases < 36

# Set this to non-zero to make output non-standard lowercase
output_lcase_=0

# Workhorse functions for the below
define letteru__(a) { # expects an integer 0 <= a <= 35
  auto oib,oob;
  oib=ibase;oob=obase;ibase=A;obase=F+1
  if(a< 0)print "_";
  if(0<=a&&a<16)print a;obase=A
  if(a==16)print "G";if(a==17)print "H";if(a==18)print "I";if(a==19)print "J"
  if(a==20)print "K";if(a==21)print "L";if(a==22)print "M";if(a==23)print "N"
  if(a==24)print "O";if(a==25)print "P";if(a==26)print "Q";if(a==27)print "R"
  if(a==28)print "S";if(a==29)print "T";if(a==30)print "U";if(a==31)print "V"
  if(a==32)print "W";if(a==33)print "X";if(a==34)print "Y";if(a==35)print "Z"
  if(a>=36)print " ",a
  ibase=oib;obase=oob;return a
}

define letterl__(a) { # expects an integer 0 <= a <= 35
  auto oib,oob;
  oib=ibase;oob=obase;ibase=obase=A
  if(a< 0)print "_";
  if(0<=a&&a<=9)print a;
  if(a==10)print "a";if(a==11)print "b"
  if(a==12)print "c";if(a==13)print "d";if(a==14)print "e";if(a==15)print "f"
  if(a==16)print "g";if(a==17)print "h";if(a==18)print "i";if(a==19)print "j"
  if(a==20)print "k";if(a==21)print "l";if(a==22)print "m";if(a==23)print "n"
  if(a==24)print "o";if(a==25)print "p";if(a==26)print "q";if(a==27)print "r"
  if(a==28)print "s";if(a==29)print "t";if(a==30)print "u";if(a==31)print "v"
  if(a==32)print "w";if(a==33)print "x";if(a==34)print "y";if(a==35)print "z"
  if(a>=36)print " ",a
  ibase=oib;obase=oob;return a
}

define letter_(mode,a) { # expects an integer 0 <= a <= 35
  auto t;
  t=a
  if(mode){if(a==0){print "_";return 0};a+=9}
  if(output_lcase_){a=letterl__(a)}else{a=letteru__(a)}
  return t
}

# By default bc will use decimal groups for 'digits' when outputting
# numbers with ibase set above 16. When ibase <= 16 letters are used as
# digits. This function outputs using letters right up to base 36 which uses
# Z as the base-1 digit. Uses obase, so no base need be specified.

# TO DO: allow setting of a sub-base for bases over the new maximum
#        rather than defaulting to bc's own decimal mode

define printbase(x) {
  auto os,sign,i,ni,f,g,a[],ai,q;
  if(2^4-6*(!!output_lcase_)>=obase){print x;return x}
  if(obase>6^2){print x;return x}
  os=scale;scale=0
  sign=1;if(x<0){sign=-1;x=-x}
  f=x-(i=x/1)
  ai=0;ni=i
  while(i){i=ni;ni=i/obase;a[++ai]=i-ni*obase}
  if(sign<0)print"-"
  if(ai){for(--ai;ai;ai--)q=letter_(0,a[ai])}else{print 0}
  if(os==0||f==0){scale=os;return sign*x}
  print"."
  g=A^scale(x)
  for(i=1;i<g;i*=obase){f*=obase;f-=letter_(0,f/1)}
  scale=os;return sign*x
}

# To do: marry these with the trunc function?

# Print numbers in 'special' format where digits are _ and A onwards
define printbase_letters(x) {
  auto os,sign,i,ni,f,g,a[],ai,q;
  if(obase> 3^3){return q=printbase(x)}
  os=scale;scale=0
  sign=1;if(x<0){sign=-1;x=-x}
  f=x-(i=x/1)
  ai=0;ni=i
  while(i){i=ni;ni=i/obase;a[++ai]=i-ni*obase}
  if(sign<0)print"-"
  if(ai){for(--ai;ai;ai--)q=letter_(1,a[ai])}else{q=letter_(1,0)}
  if(os==0||f==0){scale=os;return sign*x}
  print"."
  g=A^scale(x)
  for(i=1;i<g;i*=obase){f*=obase;f-=letter_(1,f/1)}
  scale=os;return sign*x
}

## Bijective base output

define printbijective(bbase,x) {
  auto os,sign,i,f,g,a[],ai,q;
  if(bbase<1)bbase=obase
  if(bbase>5*7){
    print "printbijective: bbase too large, using "
    if(obase>5*7){print "decimal\n";bbase=A}else{print "obase\n";bbase=obase}
  }
  os=scale;scale=0
  sign=1;if(x<0){sign=-1;x=-x}
  bbase/=1
  f=x-(i=x/1)
  ai=0;while(i)i=(i-(a[++ai]=((i-1)%bbase)+1))/bbase
  if(sign<0)print"-";g=0
  if(ai){for(.=.;ai;ai--)q=letter_(0,a[ai])}else{print".";g=1}
  if(os==0||f==0){scale=os;return sign*x}
  # Fractional part - not really valid for bijectional so made something up
  # New terminology .{3}2A2 = 0.000302 {3} representing the shift-right of 3 places
  if(!g)print ".";if(bbase==1){print "{}";scale=os;return sign*x}
  g=f;for(i=-1;g<=1;i++)g*=bbase
  if(i){print "{";i=printbijective(bbase,i);print "}"}
  g=A^scale(x)-1
  for(i=1;i<g;i*=ibase)f*=bbase
  f=printbijective(bbase,f)
  scale=os;return sign*x
}

# Print numbers in 'special' format where digits are _ and A onwards
define printbijective_letters(bbase,x) {
  auto os,sign,i,f,g,a[],ai,q;
  if(bbase<1)bbase=obase
  if(bbase>2*D){
    print "printbijective_letters: bbase too large, using "
    if(obase>2*D){print "hexavigintimal\n";bbase=2*D}else{print "obase\n";bbase=obase}
  }
  os=scale;scale=0
  sign=1;if(x<0){sign=-1;x=-x}
  f=x-(i=x/1)
  ai=0;while(i)i=(i-(a[++ai]=((i-1)%bbase)+1))/bbase
  if(sign<0)print"-";g=0
  if(ai){for(.=.;ai;ai--)q=letter_(1,a[ai])}else{print ".";g=1}
  if(os==0||f==0){scale=os;return sign*x}
  # Fractional part - not really valid for bijectional so made something up
  # New terminology .{C}BJB = .___C_B {C} representing the shift-right of 3 places
  if(!g)print ".";if(bbase==1){print "{}";scale=os;return sign*x}
  g=f;for(i=-1;g<=1;i++)g*=bbase
  if(i){print "{";i=printbijective_letters(bbase,i);print "}"}
  g=A^scale(x)-1
  for(i=1;i<g;i*=ibase)f*=bbase
  f=printbijective_letters(bbase,f)
  scale=os;return sign*x
}

## Negative base output. Workhorse for universal printsbase() function

define printnegabase_(base,x) {
  auto os,i,b2,d,a[],shft
  if(x==0){.=letter_(!!printsbase_letters_,0);return 0}
  os=scale;scale=0;base/=1
  if(base>1)base=-base
  if(base>-2)base=-obase
  if(base<-6*6){}
  b2=base*base;bijective=!!bijective
  i=x/1;shft=0;if(x!=i)shft=1
  if(shft){
    d=scale(x);if(bijective)d=os
    d=A^d
    shft=-1
    for(i=1;i<=d;i*=b2).=shft++
    shft+=shft
    x*=i/b2
  }
  for(i=1;x;i++){
    d=((x-bijective)%base)+bijective;if(d<bijective)d-=base;a[i]=d/1
    if(shft)if(!--shft)a[++i]=-1
    x=(x-d)/base
  }
  if(shft){
    if(!bijective){
      while(shft--)a[i++]=0
    } else {
      a[i++]=-1-shft
    }
    a[i++]=-1
  }
  for(--i;i;i--)if((d=a[i])<-1) {
    print "{";.=printnegabase_(base,-1-d);print "}"
  } else if(d==-1){
   print "."
  } else {
   .=letter_(!!printsbase_letters_,a[i])
  }
  scale=os;return 0
}

## Universal output

# Uses global variable 'bijective' and internal setting 'printsbase_letters_' 
# to choose from the above print{base|bijective}[_letters] functions, allowing
# the same function template to be used for all cases

bijective=0 # intended for global use like 'scale'
printsbase_letters_=0 # internal

define printsbase(base,x) {
  auto os,oob;
  os=scale;scale=0
   base/=1
   if(0<=base&&base<2)base=obase
   if(base==-1)base=-obase
  scale=os
  if(base<0){return x+printnegabase_(base,x)}
  if(bijective){
    if(printsbase_letters_){
      return printbijective_letters(base,x);
    } else {
      return printbijective(base,x);
    }
  }
  oob=obase;obase=base
  if(printsbase_letters_){
    x=printbase_letters(x)
  } else {
    x=printbase(x)
  }
  obase=oob;return x
}

define printsobase(x) {
  if(bijective){
    if(printsbase_letters_){
      return printbijective_letters(obase,x);
    } else {
      return printbijective(obase,x);
    }
  }
  if(printsbase_letters_){
    return printbase_letters(x);
  } else {
    return printbase(x);
  }
}

## Factorial base

pfactb_zero_=0 # set to 1 to show useless 1! places
define printfactorialbase(x) {
  auto os,f,t,x[],f[],xi,fi,b,bf,max
  if(x<0){print "-";x=-x}
  os=scale;scale=0
  x-=(f=x-x/1)
  max=f*A^(os-1)
  bf=1;xi=fi=0
  #for(b=1;x        ;b++){x[xi++]=x-(t=x/b)*b ;x=t }
  x+=(bijective=!!bijective)
  for(b=1;x        ;b++){x[xi++]=x-(t=(x-bijective)/b)*b ;x=t }
  if(f)if(bijective){
    print "printfactorialbase: warning - fp bijective mode undefined\n";
    f=0
  }else{
    scale=os;f+=A^-os;scale=0
  }
  for(b=1;f&&bf<max;b++){t=(f*=b)/1;f-=t;f[fi++]=t;bf*=b}
  .=--xi;.=--fi
  for(xi=xi;xi>=(!pfactb_zero_||bijective);xi--)print " ",x[xi]
  if(fi<0){scale=os;return 0}
  for(fi=fi;fi>=0&&!f[fi];fi--){};.=fi++
  print "."
  for(xi=!pfactb_zero_;xi<fi;xi++){if(xi!=!pfactb_zero_)print " ";print f[xi]}
  scale=os;return 0;
}

#scale=100;a=sqrt(2)-1;max=10^(scale-1);bf=1;for(b=1;bf<max&&a;b++){a*=b;a-=(n=int(a))
#;print n,",";bf*=b};-1

## Fractions

# Prints a and b as a fraction in smallest terms
# ** This function requires gcd() and int() from funcs.bc
define printsft(a,b) { #smallest fractional terms
  auto c,d,e
  c=gcd(a,b);
  d=int(a/c);
  e=int(b/c);
  print a,"/",b," = ",d,"/",e;
  return(d/e)
}

# Prints x as the most accurate fraction possible under the restraint of
# a maximum denominator. Can choose improper fraction style if required.
# Will always choose a/b style for fractions less than one.
# e.g. q=printfrac(0, 9, 1.75) will print 1+3/4 (one plus three quarters)
#      q=printfrac(1, 9, 1.75) will print 7/4 (seven quarters)
# output can be copy/pasted back into bc as valid syntax, hence using "+"
# (or "-" in the case of negative fractions) to separate whole part from
# fractional part in proper fractions.
#
# cf.bc contains a better/faster version of this function but with
# only the "improper" parameter
#
define printfrac(improper, maxdenom, x) {
  auto os,oib,best,sign,fx,f,sd,d,eps;
  eps=A^(3-scale);if(eps>1)eps=1
  improper=!!improper
  sign=1;if(x<0){sign=-1;x=-x}
  if(x<1)improper=1
  if(maxdenom<0)maxdenom=-maxdenom
  if(maxdenom<5)maxdenom=5
  if(maxdenom<obase)maxdenom=obase-1
  os=scale;scale=0
  oib=ibase;ibase=A
  fx=x-x/1;best=1
  for(d=1;d<=maxdenom;d++){
    f=fx*d;f-=f/1;if(2*f>1)f=1-f
    if(f<best){
      best=f;sd=d
      if(best<eps)break
    }
  }
  if(sign<0){print "-"}else{print " "}
  if(improper){
    x=(x*sd+.5)/1
    print x
    if(sd>1)print"/",sd
    ibase=oib;scale=os;return x/sd
  } else {
    x/=1
    fx=(fx*sd+.5)/1
    if(sd==1){x+=fx;fx=0}
    print x
    if(fx>0){
      if(sign<0){print "-"}else{print "+"}
      print fx,"/",sd
    }
    ibase=oib;scale=os;return sign*(x+fx/sd)
  }
}
  
# Time/Degrees output
# e.g. q=printdms(54.671) prints 54:40:15.600
define printdms(x){
  auto os,ox,h,m;
  os=scale;scale=0;ox=x
  h=x/1;x-=h;x*=F*4
  m=x/1;x-=m;x*=F*4
  print h,":",m,":",x
  scale=os;return ox
}

## Other formatting

# Truncate trailing zeroes or nines (in base ten at least) from a scaled number

#  This function is to counter bc's habit of multiple repeated zeroes or
#  base-minus-ones to the far right after the 'basimal' point, especially
#  when the 'scale' was set too high for the calculation which created x

# example code:
# scale=10;x=1/4;x;trunc(x);x-=10^-scale;x;trunc(x)
# .2500000000
# .25
# .2499999999
# .25

define trunc(x) {
  auto os,ts,s,d,tx;
  os=scale
  d=length(x)-scale(x)
  if(d<5||d>scale)d=5
  ts=scale-d
  if(scale>=d+d){
    scale=ts
    s=1;if(x<0)s=-1
    x+=s*A^-scale
    .=scale--;x/=1
  }
  for(scale=0;scale<=ts;scale++)if(x==(tx=x/1)){x=tx;break}
  scale=os;return(x)
}

# Print an integer in a field width
define intprint(w, n){ # w is field width
 auto os,m,i;
 os=scale;scale=0;n/=1
 m=n;w+=(m!=0);if(m<0){m=-m;.=w--}
 for(.=.;m>0;w--){m/=obase}
 for(i=1;i<w;i++)print " "
 scale=os;return(n)
}

# workhorse function for the below
define comma_(x,gp) {
  t=x%gp
  if(x>=gp){
    t+=comma_(x/gp,gp);print ","
    for(gp/=obase;gp>=obase;gp/=obase)if(t<gp)print 0
  }
  print t;return 0
}

# Print a number with comma dividers using given spacing
#  e.g. commaprint(1222333, 3) prints 1,222,333
define commaprint(x,g){
  auto os,sign;
  if(g<1)g=1
  sign=1;if(x<0){sign=-1;x=-x}
  os=scale;scale=0
  if(sign<0)print "-"
  x+=comma_(x,obase^(g/1))
  scale=os;return sign*x
}

# C-like printf %f function
#  format is to be given as two numbers
# prints a number in a set field width with a specified precision
# Special features:
#  negative    width     specifies left alignment within the field
#  non-integer precision specifies leading zeroes where field is right aligned
#  zero        precision specifies integer formatting only. No decimal point
#  0.0         precision combines  the above two features (zero filled integer)

define printff(width, precision, n) {
  auto os, align, leadz, signn, intn, fracn, i;
  if(obase>6^2){print "[obase>max]";return n}
  os=scale;scale=0
   leadz=0
   if(scale(precision)>0){precision/=1;leadz=1}
   if(precision<0)precision=-precision
   align=1 #right
   width/=1
   if(width<0){width=-width;align=-1} #left
   signn=1
   if(n<0){n=-n;signn=-1;.=width--}
   i=intn=n/1;fracn=n-intn
   .=width--
   for(.=.;i/=obase;width--){}
   if(precision)width-=precision+1
   
   if( leadz&&signn==-1)print "-"
   if(align== 1)for(i=0;i<width;i++)if(leadz){print "0"}else{print " "}
   if(!leadz&&signn==-1)print "-"
   i=printbase(intn) # bijective unsupported
   if(precision>0){
     print "."
     fracn*=obase^precision
     i=printff(precision, 0.0, fracn/1)
   }
   if(align==-1)for(i=0;i<width;i++)print " "
  scale=os
  return n
}

# C-like printf %e function
#  format is to be given as two numbers
# prints a number in a set field width with a specified precision
# Special features as for printff above, plus:
#  negative precision specifies grouped engineering notation

define printfe(width, precision, n) {
  auto os,oib,op,on,explen,engstep,exp,align,signn,i;
  if(obase>6^2){print "[obase>max]";return n}
  op=precision
  on=n
  os=scale;scale=0
   oib=ibase;ibase=A
    explen=9/(obase-0.72)+2
    engstep=sqrt(135/obase)/1
   ibase=oib
   signn=1
   if(n<0){signn=-1;n=-n}
   align=1
   if(width<0){align=-1;width=-width}
   if(precision<0){precision=-precision}else{engstep=1}
   exp=0
   if(n)while(n/1<1){n*=obase;.=exp--}
   precision+=precision
   precision+=engstep-1
   while(n/1>=obase){scale=precision;n/=obase;scale=0;.=exp++}
   for(.=.;exp%engstep;exp--)n*=obase
   width-=explen+2
   if(width<0)width=0
   i=printff(align*width, op, signn*n)
   print "e"
   if(exp>=0)print "+"
   i=printff(explen, 0.0, exp)
  scale=os
  return n
}

# Print the specified whitespace characters
define printspc(n)  { if(n>0)for(i=0;i< n;i++)print " "  }
define printtabs(n) { if(n>0)for(i=0;i< n;i++)print "\t" }
define newline() { print "\n" }


###from http://phodd.net/gnu-bc/code/output_graph.bc
### Output-Graph.BC - rudimentary functions for creating rudimentary drawings
###Powerful formatting tools for GNU bc. Most functions here should have their return value assigned to a variable, and unless otherwise specified here, will return the value of the number they were asked to print.
###    Bases ≤ 36
###    Base 27 (and others) with letters
###    Bijective representations
###    Negative base representations
###    Fractions
###    PrintF (C-like)
###    Commas
###    Truncation / Rounding 

screen_x = .75 * 80 + 1
screen_y = .75 * 40 + 1

# Perform a bitwise logical OR of x and y
#  taken from an old version of logic.bc
#  Only works on positive integers
#  which is fine for this library
define or_(x,y) {
 auto z,t,os;os=scale;scale=0;z=0;t=1
 while(x||y){if(x%2||y%2)z+=t;t+=t;x/=2;y/=2}
 scale=os;return (z)
}

define screen_printchar_(c) {
  if(c==0)print" "
  if(c==1)print"|"
  if(c==2)print"-"
  if(c==3)print"+"
  if(c==4)print"."
  if(c==5)print"!"
  if(c==6)print"o"
  if(c==7)print"*"
  if(c==8)print","
  if(c==9)print"_"
  if(c==A)print"~"
  if(c==B)print"$"
  if(c==C)print";"
  if(c==D)print":"
  if(c==E)print"="
  if(c==F)print"#"
  if(0>c||c>F)print "?"
  return c;
}

define screen_clear() {
  auto x,y;
  for(y=0;y<screen_y;y++)for(x=0;x<screen_x;x++)screen[y*screen_x+x]=0
  return 0;
}

define screen_plot(x,y,c) {
  auto os,s;
  os=scale;scale=0
  x/=1;y/=1;c/=1
  if(0>x||x>=screen_x||0>y||y>=screen_y){
    scale=os
    return 0
  }
  if(c<0){
    c=-c
    s=screen[y*screen_x+x]
    c=or_(c,s)
  }
  screen[y*screen_x+x]=c
  scale=os
  return 1
}

define screen_axes(xx,yy) {
  auto x,y,q,e;
  q=1
  for(y=0;y<screen_y;y++){e=screen_plot(xx,y,-1);q*=e}
  for(x=0;x<screen_x;x++){e=screen_plot(x,yy,-2);q*=e}
  return q
}

define screen_print() {
  auto x,y,q;
  for(x=0;x<screen_x;x+=2)print"-=";print"\n"
  for(y=screen_y-1;y>=0;y--){
    for(x=0;x<screen_x;x++)q=screen_printchar_(screen[y*screen_x+x])
    print "\n"
  }
  for(x=0;x<screen_x;x+=2)print"-=";print"\n"
  return 0;
}

/* define graphx(a[],si,ei) {
  auto i, j, k, l, max, min, range, pagepos, sub_x, sign, midbar, len_ei, len_diff, len_bar

  if(1- ( 0 <= si && si < ei && ei <= 65535 ) ) {
    print "Bad parameters in graphx()\n"
    return(1/0)
  }

  max = a[si]
  min = max
  for(i=si+0;i<=ei;i++){
    if(a[i] < min) min = a[i]
    if(a[i] > max) max = a[i]
    print "a[",i,"] = ",a[i],"\n";
  }

  print " max : ", max ,"\n";
  print " min : ", min ,"\n";

  sign = 1
  midbar = 0
  sub_x = 1

  if(min < 0) {
    if(max < 0) {

      sign   = -1
      sub_x  =  min
      min    = -max
      max    = -sub_x

    } else { # min < 0, max > 0 

      midbar = 1
      sub_x  = 0

    }
  }
  sub_x *= 0.9 * min
  range  = max - min

  print "range: ",range,"\n";
  print " max : ", max ,"\n";
  print " min : ", min ,"\n";
  print "sub_x: ",sub_x,"\n";

  len_ei = length(ei)
  len_line = screen_x - len_ei - 2;
  pagepos=1;

  for(i=si;i<=ei;i++) {

    len_diff = len_ei - length(i)
    if (len_diff) for(j=1;j<=len_diff;j++) print " ";
    print i,":";

    if (midbar) {
      if (len_bar < 0) {
        len_bar = ((a[i]-min) / range) * len_line
        for(j=1;j<len_bar;j++)print" ";
        if(j-len_bar){print "<";}else if(len_bar){print " ";}
        for(j=len_bar;j<=min/range*len_line;j++)print "#";
        print "|";
      } else {
        len_bar = (a[i] / range) * len_line
        for(j=1;j<=min/range*len_line;j++)print " ";
        print "|";
        for(j=1;j<len_bar;j++)print"#";
        if(j-len_bar)print ">";
      }
    } else {
      print "|";
      len_bar = ((sign*a[i]-sub_x) / max) * len_line
      if (len_bar>=1){for(j=1;j<=len_bar;j++) print "#";} 
      if (len_bar-j) print ">";
    }
    print "\n";
    .=pagepos++;
    if(pagepos >= screen_y) {
      print "Type 0 then hit [Enter]...\n";
      pagepos = read()*0 + 1
    }
  } # end for
  return
}

for(i=0;i<=10;i++)x[i]=i-5

graphx(x[],0,10)
quit
*/


###http://phodd.net/gnu-bc/code/output_roman.bc
### Output-Roman.BC - Print numbers with extended Roman-style numerals
### A one-function library for displaying numbers in Roman style. 
### Roman Numerals

# Set this to non-zero to make output non-standard lowercase
output_lcase_=0

define printroman(n) {
  auto os,t[],ti,i,d,f,x;
  if(n==0){if(output_lcase_){print"n"}else{print "N"};return 0}
  os=scale;scale=0
  f=n-(x=n/1);
  for(ti=0;x>=4000;ti++){t[ti]=x%1000;x/=1000}
  t[ti]=x
  for(.=.;ti>=0;ti--){
    x=t[ti]
    if(x){if(ti<5){for(i=0;i<ti;i++)print"("}else{print"("}}
    d=(x/1000)%10
    for(i=d;i;i--)if(output_lcase_){print"m"}else{print"M"}
    d=(x/100)%10
    if(d==4)if(output_lcase_){print"cd"}else{print"CD"}
    if(d==9)if(output_lcase_){print"cm"}else{print"CM"}
    if(4<d&&d<9)if(output_lcase_){print"d"}else{print "D"}
    if((i=d%5)<4)for(.=.;i;i--)if(output_lcase_){print"c"}else{print"C"}
    d=(x/10)%10
    if(d==4)if(output_lcase_){print"xl"}else{print"XL"}
    if(d==9)if(output_lcase_){print"xc"}else{print"XC"}
    if(4<d&&d<9)if(output_lcase_){print"l"}else{print "L"}
    if((i=d%5)<4)for(.=.;i;i--)if(output_lcase_){print"x"}else{print"X"}
    d=x%10
    if(d==4)if(output_lcase_){print"iv"}else{print"IV"}
    if(d==9)if(output_lcase_){print"ix"}else{print"IX"}
    if(4<d&&d<9)if(output_lcase_){print"v"}else{print "V"}
    if((i=d%5)<4)for(.=.;i;i--)if(output_lcase_){print"i"}else{print"I"}
    if(x){if(ti<5){for(i=0;i<ti;i++)print")"}else{print")[";ti=printroman(ti);print"];"}}
  }
  if(!f){scale=os;return n}
  if(x)print " "
  x=A^(os/2-1)
  scale=os;f+=A^-os;scale=0
  while(x&&f){
    f*=C;d=f/1;f-=d
    if(d>=6){if(output_lcase_){print"s"}else{print"S"};d-=6}
    if(d==1)print".";if(d==2)print":"
    if(d==3)print":.";if(d==4)print"::"
    if(d==5)print"::.";
    x/=C;if(x&&f)print"/"
  }
  scale=os;return n
}

###from http://phodd.net/gnu-bc/code/rand/rand.bc
### A floating-point based random number generator. Since bc has no method of obtaining an initial seed, use of randbc is highly recommended. For a sample guessing game which uses this library see guess.bci 

# Random number generator algorithm and code
# Not guaranteed for any purpose
# Chi-square tests prove this algorithm to be favourable

# ********************************************************
# ******************  IMPORTANT NOTICE  ******************
# ********************************************************
# An external seed source is required to start this library!
# See the bash randbc script for an example of how to do this.
# (It's available from the same website you found this file)

scale=50;ibase=A
# Global variables. Not to be changed in code without really good reason
rand_seed_ = 3482.2023+sqrt(8)
rand_mult_ = sqrt(2)+sqrt(3)
rand_smax_ = 2^32
rand_last_ = 0

define srand(x) {
  auto os,z,f,i;
  if(x<0){
    .=srand(x=-x);z=rand_seed_
    .=srand(sqrt(x)+x)
    rand_seed_=(z+rand_seed_)/2
    return 0
  }
  os=scale
  z=x+=sqrt(5);x+=sqrt(x);x-=sqrt(x)
  x+=1/2;x*=20/13
  scale=0
   f=(x-(i=x/1))
  scale=os
  z-=f*i;if(z<0)z=-z
  rand_seed_=z
  scale=os;return 0
}

define rand(x) {
  auto i, f, os;

  if(x<0)return srand(x)
  if(x<1)return(rand_last_)

  os = scale + 10
  scale = 0  ; i = rand_seed_ / 1
  scale = os ; f = rand_seed_ - i

  rand_seed_ = rand_mult_ * (1+i) * (1+f)

  while(rand_seed_>rand_smax_)rand_seed_-=rand_smax_

  scale = 0  ; i = rand_seed_ / 1
  scale = os ; f = rand_seed_ - i

  rand_last_ = f
  if(x==1){scale=os-10;return(rand_last_/=1)}

  rand_last_ = f * x + 1
  scale = 0        ; rand_last_ /= 1
  scale = scale(x) ; rand_last_ /= 1
  scale = os - 10
  
  return(rand_last_)
}

###from http://phodd.net/gnu-bc/code/thermometer.bc
###Temperature scale conversions amongst the five most common scales.

### Celcius / centigrade
### Farenheit
### Rankin
### Réamur
### Kelvin

# Caution: These functions will not operate correctly if ibase is not
# set to base ten (A) nor if scale is set too low
define   celcius_to_farenheit( c ) { ibase=10; return (c * 1.8 + 32)           }
define   celcius_to_kelvin(    c ) { ibase=10; return (c + 273.15)             }
define   celcius_to_reamur(    c ) { ibase=10; return (c * 0.8)                }
define   celcius_to_rankine(   c ) { ibase=10; return (c * 1.8 + 491.67)       }
define farenheit_to_celcius(   f ) { ibase=10; return ((f - 32)/1.8)           }
define farenheit_to_kelvin(    f ) { ibase=10; return ((f + 459.67)/1.8)       }
define farenheit_to_reamur(    f ) { ibase=10; return ((f - 32)/2.25)          }
define farenheit_to_rankine(   f ) { ibase=10; return (f + 459.67)             }
define    kelvin_to_celcius(   k ) { ibase=10; return (k - 273.15)             }
define    kelvin_to_farenheit( k ) { ibase=10; return (k * 1.8 - 459.67)       }
define    kelvin_to_reamur(    k ) { ibase=10; return ((k - 273.15)*0.8)       }
define    kelvin_to_rankine(   k ) { ibase=10; return (k * 1.8)                }
define    reamur_to_celcius(   r ) { ibase=10; return (r / 0.8)                }
define    reamur_to_farenheit( r ) { ibase=10; return (r * 2.25 + 32)          }
define    reamur_to_kelvin(    r ) { ibase=10; return (r / 0.8 + 273.15)       }
define    reamur_to_rankine(   r ) { ibase=10; return (r * 2.25 + 491.67)      }
define   rankine_to_celcius(   r ) { ibase=10; return (r / 1.8 + 273.15)       }
define   rankine_to_farenheit( r ) { ibase=10; return (r - 459.67)             }
define   rankine_to_kelvin(    r ) { ibase=10; return (r / 1.8)                }
define   rankine_to_reamur(    r ) { ibase=10; return ((r / 1.8 + 273.15)*0.8) }
 
